import{s as yt,a as On,u as Wn,g as Kn,b as Jn,n as U,x as at,o as Oi}from"../chunks/scheduler.BeaK0CkN.js";import{S as _t,i as bt,e as j,c as P,h as R,f as o,b as v,d as m,m as y,n as _,r as Wi,p as Ki,z as Ui,t as c,v as b,j as h,w as k,k as $,x as I,y as M,l as Sa,s as T,a as x,A as Ji,g as tt,B as Yi}from"../chunks/index.D8_ZxPLa.js";import{b as Q}from"../chunks/paths.DPzQ3N3X.js";const Xi=typeof window<"u"?window:typeof globalThis<"u"?globalThis:global;function Xn(l){return(l==null?void 0:l.length)!==void 0?l:Array.from(l)}function Zi(l){let e,t,s;const a=l[4].default,n=On(a,l,l[3],null);return{c(){e=j("a"),n&&n.c(),this.h()},l(i){e=P(i,"A",{href:!0,class:!0,target:!0,rel:!0});var r=R(e);n&&n.l(r),r.forEach(o),this.h()},h(){v(e,"href",l[0]),v(e,"class",t="font-medium text-blue-600 dark:text-blue-500 hover:underline "+l[1]),v(e,"target",l[2]),v(e,"rel","noopener noreferrer")},m(i,r){m(i,e,r),n&&n.m(e,null),s=!0},p(i,[r]){n&&n.p&&(!s||r&8)&&Wn(n,a,i,i[3],s?Jn(a,i[3],r,null):Kn(i[3]),null),(!s||r&1)&&v(e,"href",i[0]),(!s||r&2&&t!==(t="font-medium text-blue-600 dark:text-blue-500 hover:underline "+i[1]))&&v(e,"class",t),(!s||r&4)&&v(e,"target",i[2])},i(i){s||(y(n,i),s=!0)},o(i){_(n,i),s=!1},d(i){i&&o(e),n&&n.d(i)}}}function Qi(l,e,t){let{$$slots:s={},$$scope:a}=e,{href:n}=e,{styling:i=""}=e,{target:r="_blank"}=e;return l.$$set=p=>{"href"in p&&t(0,n=p.href),"styling"in p&&t(1,i=p.styling),"target"in p&&t(2,r=p.target),"$$scope"in p&&t(3,a=p.$$scope)},[n,i,r,a,s]}class B extends _t{constructor(e){super(),bt(this,e,Qi,Zi,yt,{href:0,styling:1,target:2})}}function Ci(l,e,t){const s=l.slice();return s[0]=e[t],s}function to(l){let e;return{c(){e=c("link")},l(t){e=h(t,"link")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Vi(l){let e,t,s=l[0].author+"",a,n,i,r=l[0].title+"",p,d,A,D=l[0].publisher+"",u,L,S,E=l[0].year+"",q,z,G,Z,J,F,st,Y;return J=new B({props:{href:l[0].link,$$slots:{default:[to]},$$scope:{ctx:l}}}),{c(){e=j("li"),t=j("span"),a=c(s),n=c(", "),i=j("span"),p=c(r),d=c(`,
			`),A=j("span"),u=c(D),L=c(`,
			`),S=j("span"),q=c(E),z=c(", "),G=j("span"),Z=c("["),b(J.$$.fragment),F=c("]"),st=c(`.
		`),this.h()},l(O){e=P(O,"LI",{});var V=R(e);t=P(V,"SPAN",{class:!0});var W=R(t);a=h(W,s),W.forEach(o),n=h(V,", "),i=P(V,"SPAN",{});var N=R(i);p=h(N,r),N.forEach(o),d=h(V,`,
			`),A=P(V,"SPAN",{});var C=R(A);u=h(C,D),C.forEach(o),L=h(V,`,
			`),S=P(V,"SPAN",{});var X=R(S);q=h(X,E),X.forEach(o),z=h(V,", "),G=P(V,"SPAN",{});var et=R(G);Z=h(et,"["),k(J.$$.fragment,et),F=h(et,"]"),et.forEach(o),st=h(V,`.
		`),V.forEach(o),this.h()},h(){v(t,"class","ms-4")},m(O,V){m(O,e,V),$(e,t),$(t,a),$(e,n),$(e,i),$(i,p),$(e,d),$(e,A),$(A,u),$(e,L),$(e,S),$(S,q),$(e,z),$(e,G),$(G,Z),I(J,G,null),$(G,F),$(e,st),Y=!0},p(O,V){const W={};V&8&&(W.$$scope={dirty:V,ctx:O}),J.$set(W)},i(O){Y||(y(J.$$.fragment,O),Y=!0)},o(O){_(J.$$.fragment,O),Y=!1},d(O){O&&o(e),M(J)}}}function eo(l){let e,t,s=Xn(Un),a=[];for(let i=0;i<s.length;i+=1)a[i]=Vi(Ci(l,s,i));const n=i=>_(a[i],1,1,()=>{a[i]=null});return{c(){e=j("ol");for(let i=0;i<a.length;i+=1)a[i].c();this.h()},l(i){e=P(i,"OL",{class:!0});var r=R(e);for(let p=0;p<a.length;p+=1)a[p].l(r);r.forEach(o),this.h()},h(){v(e,"class","pl-5 my-2 text-xs list-decimal")},m(i,r){m(i,e,r);for(let p=0;p<a.length;p+=1)a[p]&&a[p].m(e,null);t=!0},p(i,[r]){if(r&0){s=Xn(Un);let p;for(p=0;p<s.length;p+=1){const d=Ci(i,s,p);a[p]?(a[p].p(d,r),y(a[p],1)):(a[p]=Vi(d),a[p].c(),y(a[p],1),a[p].m(e,null))}for(Wi(),p=s.length;p<a.length;p+=1)n(p);Ki()}},i(i){if(!t){for(let r=0;r<s.length;r+=1)y(a[r]);t=!0}},o(i){a=a.filter(Boolean);for(let r=0;r<a.length;r+=1)_(a[r]);t=!1},d(i){i&&o(e),Ui(a,i)}}}const Zn=l=>{for(let e=0;e<Un.length;e++)if(Un[e].id==l)return{index:e+1,link:Un[e].link};throw new Error},Un=[{id:"gilpin",author:"William Gilpin",title:"Model scale versus domain knoweldge in statistical forecasting of chaotic systems",publisher:"Phys. Rev. Res., vol. 5, pp. 043252, Dec",year:2023,link:"https://link.aps.org/doi/10.1103/PhysRevResearch.5.043252"},{id:"seo",author:"Seo, J., Kim, S., Jalalvand, A. et al.",title:"Avoiding fusion plasma tearing instability with deep reinforcement learning",publisher:"Nature",year:"2024",link:"https://doi.org/10.1038/s41586-024-07024-9"},{id:"degrave",author:"Jonas Degrave, Federico Felici, Jonas Buchli, Michael Neunert, Brendan Tracey, Francesco Carpanese, Timo Ewalds, Roland Hafner, et. al.",title:"Magnetic control of tokamak plasmas through deep reinforcement learning",publisher:"Nature",year:"2021",link:"https://doi.org/10.1038/s41586-021-04301-9"},{id:"challu",author:"Cristian Challu, Kin G. Olivares, Boris N. Oreshkin, Federico Garza, Max Mergenthaler-Canseco, Artur Dubrawski",title:"N-HiTS: Neural Hierarchical Interpolation for Time Series Forecasting",publisher:"arXiv:2201.12886",year:"2022",link:"https://arxiv.org/abs/2201.12886"},{id:"oreshkin",author:"Boris N. Oreshkin, Dmitri Carpov, Nicolas Chapados, Yoshua Bengio",title:"N-BEATS: Neural Basis Expansion Analaysis for Interpretable Time Series Forecasting",publisher:"arXiv:1905.10437",year:"2019",link:"https://arxiv.org/abs/1905.10437"},{id:"osinga",author:"Hinke M. Osinga",title:"Understanding the geometry of dynamics: the stable manifold of the Lorenz system",publisher:"Journal of the Royal Society of New Zealand",year:"2018",link:"https://doi.org/10.1080/03036758.2018.1434802"}];class no extends _t{constructor(e){super(),bt(this,e,null,eo,yt,{})}}function so(l){let e=Zn(l[0]).index+"",t;return{c(){t=c(e)},l(s){t=h(s,e)},m(s,a){m(s,t,a)},p(s,a){a&1&&e!==(e=Zn(s[0]).index+"")&&Sa(t,e)},d(s){s&&o(t)}}}function ao(l){let e,t,s,a;return t=new B({props:{href:Zn(l[0]).link,$$slots:{default:[so]},$$scope:{ctx:l}}}),{c(){e=c("["),b(t.$$.fragment),s=c("]")},l(n){e=h(n,"["),k(t.$$.fragment,n),s=h(n,"]")},m(n,i){m(n,e,i),I(t,n,i),m(n,s,i),a=!0},p(n,[i]){const r={};i&1&&(r.href=Zn(n[0]).link),i&3&&(r.$$scope={dirty:i,ctx:n}),t.$set(r)},i(n){a||(y(t.$$.fragment,n),a=!0)},o(n){_(t.$$.fragment,n),a=!1},d(n){n&&(o(e),o(s)),M(t,n)}}}function io(l,e,t){let{id:s}=e;return l.$$set=a=>{"id"in a&&t(0,s=a.id)},[s]}class K extends _t{constructor(e){super(),bt(this,e,io,ao,yt,{id:0})}}function oo(l){let e,t;const s=l[2].default,a=On(s,l,l[1],null);return{c(){e=j("div"),a&&a.c(),this.h()},l(n){e=P(n,"DIV",{id:!0,class:!0});var i=R(e);a&&a.l(i),i.forEach(o),this.h()},h(){v(e,"id",l[0]),v(e,"class","text-2xl font-bold text-center my-8")},m(n,i){m(n,e,i),a&&a.m(e,null),t=!0},p(n,[i]){a&&a.p&&(!t||i&2)&&Wn(a,s,n,n[1],t?Jn(s,n[1],i,null):Kn(n[1]),null),(!t||i&1)&&v(e,"id",n[0])},i(n){t||(y(a,n),t=!0)},o(n){_(a,n),t=!1},d(n){n&&o(e),a&&a.d(n)}}}function ro(l,e,t){let{$$slots:s={},$$scope:a}=e,{id:n}=e;return l.$$set=i=>{"id"in i&&t(0,n=i.id),"$$scope"in i&&t(1,a=i.$$scope)},[n,a,s]}class Fn extends _t{constructor(e){super(),bt(this,e,ro,oo,yt,{id:0})}}function lo(l){let e,t;const s=l[2].default,a=On(s,l,l[1],null);return{c(){e=j("div"),a&&a.c(),this.h()},l(n){e=P(n,"DIV",{id:!0,class:!0});var i=R(e);a&&a.l(i),i.forEach(o),this.h()},h(){v(e,"id",l[0]),v(e,"class","text-xl font-medium text-left mt-8 mb-4")},m(n,i){m(n,e,i),a&&a.m(e,null),t=!0},p(n,[i]){a&&a.p&&(!t||i&2)&&Wn(a,s,n,n[1],t?Jn(s,n[1],i,null):Kn(n[1]),null),(!t||i&1)&&v(e,"id",n[0])},i(n){t||(y(a,n),t=!0)},o(n){_(a,n),t=!1},d(n){n&&o(e),a&&a.d(n)}}}function fo(l,e,t){let{$$slots:s={},$$scope:a}=e,{id:n}=e;return l.$$set=i=>{"id"in i&&t(0,n=i.id),"$$scope"in i&&t(1,a=i.$$scope)},[n,a,s]}class Bn extends _t{constructor(e){super(),bt(this,e,fo,lo,yt,{id:0})}}function co(l){let e,t,s;const a=l[3].default,n=On(a,l,l[2],null);return{c(){e=j("p"),n&&n.c(),this.h()},l(i){e=P(i,"P",{class:!0});var r=R(e);n&&n.l(r),r.forEach(o),this.h()},h(){v(e,"class",t="my-2 "+l[0]+" "+l[1])},m(i,r){m(i,e,r),n&&n.m(e,null),s=!0},p(i,[r]){n&&n.p&&(!s||r&4)&&Wn(n,a,i,i[2],s?Jn(a,i[2],r,null):Kn(i[2]),null),(!s||r&3&&t!==(t="my-2 "+i[0]+" "+i[1]))&&v(e,"class",t)},i(i){s||(y(n,i),s=!0)},o(i){_(n,i),s=!1},d(i){i&&o(e),n&&n.d(i)}}}function ho(l,e,t){let{$$slots:s={},$$scope:a}=e,{indent:n="indent-8"}=e,{style:i=""}=e;return l.$$set=r=>{"indent"in r&&t(0,n=r.indent),"style"in r&&t(1,i=r.style),"$$scope"in r&&t(2,a=r.$$scope)},[n,i,a,s]}class H extends _t{constructor(e){super(),bt(this,e,ho,co,yt,{indent:0,style:1})}}function Fi(l,e,t){const s=l.slice();return s[1]=e[t],s}function Bi(l){let e,t,s=l[1].desc+"",a,n,i,r,p=l[1].val+"",d,A;return{c(){e=j("li"),t=j("div"),a=c(s),n=T(),i=j("div"),r=j("span"),d=c(p),A=T(),this.h()},l(D){e=P(D,"LI",{class:!0});var u=R(e);t=P(u,"DIV",{class:!0});var L=R(t);a=h(L,s),L.forEach(o),n=x(u),i=P(u,"DIV",{class:!0});var S=R(i);r=P(S,"SPAN",{class:!0});var E=R(r);d=h(E,p),E.forEach(o),S.forEach(o),A=x(u),u.forEach(o),this.h()},h(){v(t,"class","flex-none w-32 sm:w-64"),v(r,"class","rounded-0.5 p-1 font-mono"),v(i,"class","w-fit flex-wrap"),v(e,"class","flex items-center justify-left")},m(D,u){m(D,e,u),$(e,t),$(t,a),$(e,n),$(e,i),$(i,r),$(r,d),$(e,A)},p(D,u){u&1&&s!==(s=D[1].desc+"")&&Sa(a,s),u&1&&p!==(p=D[1].val+"")&&Sa(d,p)},d(D){D&&o(e)}}}function uo(l){let e,t,s=Xn(l[0]),a=[];for(let n=0;n<s.length;n+=1)a[n]=Bi(Fi(l,s,n));return{c(){e=j("section"),t=j("ul");for(let n=0;n<a.length;n+=1)a[n].c();this.h()},l(n){e=P(n,"SECTION",{class:!0});var i=R(e);t=P(i,"UL",{class:!0});var r=R(t);for(let p=0;p<a.length;p+=1)a[p].l(r);r.forEach(o),i.forEach(o),this.h()},h(){v(t,"class","flex flex-col m-auto ps-2 rounded gap-0.5 bg-gray-100 divide-y divide-gray-200 w-fit"),v(e,"class","relative block my-4")},m(n,i){m(n,e,i),$(e,t);for(let r=0;r<a.length;r+=1)a[r]&&a[r].m(t,null)},p(n,[i]){if(i&1){s=Xn(n[0]);let r;for(r=0;r<s.length;r+=1){const p=Fi(n,s,r);a[r]?a[r].p(p,i):(a[r]=Bi(p),a[r].c(),a[r].m(t,null))}for(;r<a.length;r+=1)a[r].d(1);a.length=s.length}},i:U,o:U,d(n){n&&o(e),Ui(a,n)}}}function mo(l,e,t){let{hps:s=[]}=e;return l.$$set=a=>{"hps"in a&&t(0,s=a.hps)},[s]}class La extends _t{constructor(e){super(),bt(this,e,mo,uo,yt,{hps:0})}}function po(l){let e,t;const s=l[1].default,a=On(s,l,l[0],null);return{c(){e=j("figcaption"),a&&a.c(),this.h()},l(n){e=P(n,"FIGCAPTION",{class:!0});var i=R(e);a&&a.l(i),i.forEach(o),this.h()},h(){v(e,"class","text-center text-xs mt-2 mx-0 sm:mx-36")},m(n,i){m(n,e,i),a&&a.m(e,null),t=!0},p(n,[i]){a&&a.p&&(!t||i&1)&&Wn(a,s,n,n[0],t?Jn(s,n[0],i,null):Kn(n[0]),null)},i(n){t||(y(a,n),t=!0)},o(n){_(a,n),t=!1},d(n){n&&o(e),a&&a.d(n)}}}function $o(l,e,t){let{$$slots:s={},$$scope:a}=e;return l.$$set=n=>{"$$scope"in n&&t(0,a=n.$$scope)},[a,s]}class nt extends _t{constructor(e){super(),bt(this,e,$o,po,yt,{})}}const go=`
\\begin{align}
\\dot{x} & = \\sigma(y-x) \\\\
\\dot{y} & = \\rho x - y - xz \\\\
\\dot{z} & = -\\beta z + xy
\\end{align}`,wo=`
\\begin{align}
\\sigma & = 10 \\\\
\\beta & = \\frac{8}{3} \\\\
\\rho & = 28 \\\\
\\end{align}`,vo=`
\\begin{align}
dt & \\approx 0.015 \\mathrm{s} \\\\
\\lambda_{max}^{-1} & \\approx 1.121 \\mathrm{s} \\\\
H = 100 \\text{ points} & \\approx 1.34\\lambda_{max}^{-1} \\\\
\\end{align}`,yo=`
\\begin{align} 
\\operatorname{\\epsilon}(t) := \\frac{200}{t} \\sum_{t'=1}^t \\frac{|\\operatorname{\\boldsymbol{y}}(t')-\\operatorname{\\boldsymbol{\\hat{y}}}(t')|}{|\\operatorname{\\boldsymbol{y}}(t')| + |\\operatorname{\\boldsymbol{\\hat{y}}}(t')|} \\\\
\\end{align}`,_o=[{desc:"horizon length",val:100},{desc:"lookback window length",val:500},{desc:"dt",val:.015008},{desc:"number of stacks",val:3},{desc:"blocks per stack",val:1},{desc:"mlp layers per block",val:4},{desc:"mlp layer size",val:1024},{desc:"activation function",val:"ReLU"},{desc:"max pooling factors",val:"2, 2, 2"},{desc:"frequency downsampling factors",val:"24, 12, 1"},{desc:"batch size",val:512},{desc:"# training steps",val:1e4},{desc:"learning rate",val:"1e-3"},{desc:"learning rate schedule",val:"halve every 3,333 steps"},{desc:"total trainable parameters",val:"~20 million"}],bo=[{desc:"number of stacks",val:4},{desc:"blocks per stack",val:8},{desc:"mlp layer size",val:2048},{desc:"max pooling factors",val:"10, 4, 2, 1"},{desc:"frequency downsampling factors",val:"25, 12, 6, 1"},{desc:"batch size",val:512},{desc:"# training steps",val:15e4},{desc:"run validation every",val:"5000 steps"},{desc:"learning rate",val:"1e-4"},{desc:"learning rate schedule",val:"halve whenever validation loss does not decrease"},{desc:"all other hyperparameters",val:"same as Model 1"},{desc:"total trainable parameters",val:"~645 million"}],ko=[{desc:"horizon",val:500},{desc:"lookback",val:2500},{desc:"dt",val:.0030016},{desc:"all other hyperparameters",val:"same as Model 2"}],{document:Ve,window:Io}=Xi;function Mo(l){let e;return{c(){e=c("mochaNN")},l(t){e=h(t,"mochaNN")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Ao(l){let e,t,s="Model scale versus domain knowledge in statistical forecasting of chaotic systems",a,n,i,r,p,d,A,D,u,L,S='<a href="#sabine">1</a>',E,q;return n=new K({props:{id:"gilpin"}}),r=new K({props:{id:"gilpin"}}),d=new K({props:{id:"seo"}}),D=new K({props:{id:"degrave"}}),{c(){e=c(`This project is inspired by several recent publications involving the use of deep
			learning to predict or control chaotic dynamical systems, in particular William Gilpin's
			paper, `),t=j("i"),t.textContent=s,a=T(),b(n.$$.fragment),i=c(`. Gilpin found that, given enough training data, generic neural
			architectures can match or exceed the performance of state-of-the-art domain-specific
			chaotic forecasting models such as reservoir computers and neural ODEs. I have recently
			become intrigued by the prospect of applying deep learning to prediction tasks involving
			chaotic systems, as I explore ways to contribute to the efforts to find technical
			solutions to climate change, and Gilpin's paper provided the impetus for me to begin
			this investigation. Along with `),b(r.$$.fragment),p=c(`, several other recent publications in
			related areas have been especially exciting to me, particularly the ones applying deep
			learning to tokamak control in nuclear fusion reactors (see e.g. `),b(d.$$.fragment),A=c(", "),b(D.$$.fragment),u=c(")"),L=j("sup"),L.innerHTML=S,E=c(`.
		`)},l(z){e=h(z,`This project is inspired by several recent publications involving the use of deep
			learning to predict or control chaotic dynamical systems, in particular William Gilpin's
			paper, `),t=P(z,"I",{"data-svelte-h":!0}),tt(t)!=="svelte-oq8z8z"&&(t.textContent=s),a=x(z),k(n.$$.fragment,z),i=h(z,`. Gilpin found that, given enough training data, generic neural
			architectures can match or exceed the performance of state-of-the-art domain-specific
			chaotic forecasting models such as reservoir computers and neural ODEs. I have recently
			become intrigued by the prospect of applying deep learning to prediction tasks involving
			chaotic systems, as I explore ways to contribute to the efforts to find technical
			solutions to climate change, and Gilpin's paper provided the impetus for me to begin
			this investigation. Along with `),k(r.$$.fragment,z),p=h(z,`, several other recent publications in
			related areas have been especially exciting to me, particularly the ones applying deep
			learning to tokamak control in nuclear fusion reactors (see e.g. `),k(d.$$.fragment,z),A=h(z,", "),k(D.$$.fragment,z),u=h(z,")"),L=P(z,"SUP",{"data-svelte-h":!0}),tt(L)!=="svelte-6x9dc9"&&(L.innerHTML=S),E=h(z,`.
		`)},m(z,G){m(z,e,G),m(z,t,G),m(z,a,G),I(n,z,G),m(z,i,G),I(r,z,G),m(z,p,G),I(d,z,G),m(z,A,G),I(D,z,G),m(z,u,G),m(z,L,G),m(z,E,G),q=!0},p:U,i(z){q||(y(n.$$.fragment,z),y(r.$$.fragment,z),y(d.$$.fragment,z),y(D.$$.fragment,z),q=!0)},o(z){_(n.$$.fragment,z),_(r.$$.fragment,z),_(d.$$.fragment,z),_(D.$$.fragment,z),q=!1},d(z){z&&(o(e),o(t),o(a),o(i),o(p),o(A),o(u),o(L),o(E)),M(n,z),M(r,z),M(d,z),M(D,z)}}}function Eo(l){let e,t,s='<a href="#paperspace">2</a>',a,n,i='<a href="#brunton">3</a>',r;return{c(){e=c(`My goal with this project is to get some hands-on experience with a chaotic system and
			probe deeper into Gilpin's findings by testing the limits of a neural network's ability
			to model a single chaotic system (within the computational constraints imposed by my
			budget`),t=j("sup"),t.innerHTML=s,a=c(`). I'll start with what is probably the most
			well known chaotic system, the Lorenz Attractor. I will approach the problem more from
			the perspective of a generalist deep learning practioner than a dynamical systems
			expert, and so I will be (re)discovering many of the properties of the Lorenz System,
			and dynamical systems in general, as I go, often using the results of my experiments to
			guide my investigation`),n=j("sup"),n.innerHTML=i,r=c(`. What exactly makes the Lorenz
			Attractor chaotic? And what constraints will that impose on the ability of a deep neural
			network to model it? Let's find out!`)},l(p){e=h(p,`My goal with this project is to get some hands-on experience with a chaotic system and
			probe deeper into Gilpin's findings by testing the limits of a neural network's ability
			to model a single chaotic system (within the computational constraints imposed by my
			budget`),t=P(p,"SUP",{"data-svelte-h":!0}),tt(t)!=="svelte-yuo1gg"&&(t.innerHTML=s),a=h(p,`). I'll start with what is probably the most
			well known chaotic system, the Lorenz Attractor. I will approach the problem more from
			the perspective of a generalist deep learning practioner than a dynamical systems
			expert, and so I will be (re)discovering many of the properties of the Lorenz System,
			and dynamical systems in general, as I go, often using the results of my experiments to
			guide my investigation`),n=P(p,"SUP",{"data-svelte-h":!0}),tt(n)!=="svelte-1n6e9eh"&&(n.innerHTML=i),r=h(p,`. What exactly makes the Lorenz
			Attractor chaotic? And what constraints will that impose on the ability of a deep neural
			network to model it? Let's find out!`)},m(p,d){m(p,e,d),m(p,t,d),m(p,a,d),m(p,n,d),m(p,r,d)},p:U,d(p){p&&(o(e),o(t),o(a),o(n),o(r))}}}function To(l){let e;return{c(){e=c("Youtube channel")},l(t){e=h(t,"Youtube channel")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function xo(l){let e;return{c(){e=c("lecture series")},l(t){e=h(t,"lecture series")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function zo(l){let e;return{c(){e=c("The Lorenz Attractor")},l(t){e=h(t,"The Lorenz Attractor")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function jo(l){let e;return{c(){e=c("Lorenz Attractor")},l(t){e=h(t,"Lorenz Attractor")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Po(l){let e,t,s,a;return t=new B({props:{href:"https://en.wikipedia.org/wiki/Lorenz_system",$$slots:{default:[jo]},$$scope:{ctx:l}}}),{c(){e=c(`The
			`),b(t.$$.fragment),s=c(` was developed
			by Edward Lorenz et. al. in 1963 as a simplified model of atmospheric convection.`)},l(n){e=h(n,`The
			`),k(t.$$.fragment,n),s=h(n,` was developed
			by Edward Lorenz et. al. in 1963 as a simplified model of atmospheric convection.`)},m(n,i){m(n,e,i),I(t,n,i),m(n,s,i),a=!0},p(n,i){const r={};i&256&&(r.$$scope={dirty:i,ctx:n}),t.$set(r)},i(n){a||(y(t.$$.fragment,n),a=!0)},o(n){_(t.$$.fragment,n),a=!1},d(n){n&&(o(e),o(s)),M(t,n)}}}function Lo(l){let e;return{c(){e=c("The Lorenz Attractor")},l(t){e=h(t,"The Lorenz Attractor")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function So(l){let e;return{c(){e=c(`The Lorenz system is comprised of three ordinary differential equations representing the
			properties of convection and horizontal and vertical temperature in a two-dimensional
			fluid layer:`)},l(t){e=h(t,`The Lorenz system is comprised of three ordinary differential equations representing the
			properties of convection and horizontal and vertical temperature in a two-dimensional
			fluid layer:`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Do(l){let e,t,s="Attractor",a;return{c(){e=c("The Lorenz "),t=j("i"),t.textContent=s,a=c(" refers to a set of chaotic solutions to the system, most commonly:")},l(n){e=h(n,"The Lorenz "),t=P(n,"I",{"data-svelte-h":!0}),tt(t)!=="svelte-7jrnvq"&&(t.textContent=s),a=h(n," refers to a set of chaotic solutions to the system, most commonly:")},m(n,i){m(n,e,i),m(n,t,i),m(n,a,i)},p:U,d(n){n&&(o(e),o(t),o(a))}}}function No(l){let e;return{c(){e=c("dysts")},l(t){e=h(t,"dysts")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Ro(l){let e,t,s,a;return t=new B({props:{href:"https://github.com/williamgilpin/dysts",$$slots:{default:[No]},$$scope:{ctx:l}}}),{c(){e=c("I used Gilpin's "),b(t.$$.fragment),s=c(` python
			module to generate the training data for this solution.`)},l(n){e=h(n,"I used Gilpin's "),k(t.$$.fragment,n),s=h(n,` python
			module to generate the training data for this solution.`)},m(n,i){m(n,e,i),I(t,n,i),m(n,s,i),a=!0},p(n,i){const r={};i&256&&(r.$$scope={dirty:i,ctx:n}),t.$set(r)},i(n){a||(y(t.$$.fragment,n),a=!0)},o(n){_(t.$$.fragment,n),a=!1},d(n){n&&(o(e),o(s)),M(t,n)}}}function qo(l){let e;return{c(){e=c("Neural Architecture: N-HiTS")},l(t){e=h(t,"Neural Architecture: N-HiTS")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Go(l){let e,t,s,a,n,i;return t=new K({props:{id:"challu"}}),a=new K({props:{id:"gilpin"}}),{c(){e=c("The N-HiTS "),b(t.$$.fragment),s=c(` forecasting network is known to produce state-of-the-art results,
			at the time of writing, for univariate time series prediction, with up to an order of magnitude
			lower computational requirement than some competitors. Given my limited budget and its strong
			performance reported in `),b(a.$$.fragment),n=c(`, it seemed like the natural starting point
			for a network architecture.`)},l(r){e=h(r,"The N-HiTS "),k(t.$$.fragment,r),s=h(r,` forecasting network is known to produce state-of-the-art results,
			at the time of writing, for univariate time series prediction, with up to an order of magnitude
			lower computational requirement than some competitors. Given my limited budget and its strong
			performance reported in `),k(a.$$.fragment,r),n=h(r,`, it seemed like the natural starting point
			for a network architecture.`)},m(r,p){m(r,e,p),I(t,r,p),m(r,s,p),I(a,r,p),m(r,n,p),i=!0},p:U,i(r){i||(y(t.$$.fragment,r),y(a.$$.fragment,r),i=!0)},o(r){_(t.$$.fragment,r),_(a.$$.fragment,r),i=!1},d(r){r&&(o(e),o(s),o(n)),M(t,r),M(a,r)}}}function Ho(l){let e,t,s,a,n,i;return t=new K({props:{id:"oreshkin"}}),a=new K({props:{id:"oreshkin"}}),{c(){e=c("The architectural ideas in N-HiTS build on those of its predecessor, N-BEATS "),b(t.$$.fragment),s=c(`, a neural basis expansion network for time series prediction. The key ideas inherited
			from N-BEATS include the organization of fully connected layers into blocks that output
			basis expansions (linear projections of the preceding fully connected layer's output)
			and the use of both forecast and backcast predictions from each block. The forecast
			predictions from all blocks are summed together to produce the final output of the
			network, while the backcasts are subtracted from the input of the corresponding block to
			produce a residual connection as the input to the next block. The goal of the backcasts
			is to help the downstream blocks by "removing components of their input that are not
			helpful for forecasting" `),b(a.$$.fragment),n=c(".")},l(r){e=h(r,"The architectural ideas in N-HiTS build on those of its predecessor, N-BEATS "),k(t.$$.fragment,r),s=h(r,`, a neural basis expansion network for time series prediction. The key ideas inherited
			from N-BEATS include the organization of fully connected layers into blocks that output
			basis expansions (linear projections of the preceding fully connected layer's output)
			and the use of both forecast and backcast predictions from each block. The forecast
			predictions from all blocks are summed together to produce the final output of the
			network, while the backcasts are subtracted from the input of the corresponding block to
			produce a residual connection as the input to the next block. The goal of the backcasts
			is to help the downstream blocks by "removing components of their input that are not
			helpful for forecasting" `),k(a.$$.fragment,r),n=h(r,".")},m(r,p){m(r,e,p),I(t,r,p),m(r,s,p),I(a,r,p),m(r,n,p),i=!0},p:U,i(r){i||(y(t.$$.fragment,r),y(a.$$.fragment,r),i=!0)},o(r){_(t.$$.fragment,r),_(a.$$.fragment,r),i=!1},d(r){r&&(o(e),o(s),o(n)),M(t,r),M(a,r)}}}function Co(l){let e,t,s,a;return t=new K({props:{id:"challu"}}),{c(){e=c(`The novel ideas from N-HiTS enable the possiblity of modeling increasingly long time
			horizons while keeping computational complexity low. They include the use of pooling
			layers that downsample the inputs to each block and upsampling layers that map a
			compressed representation of the forecast to the output sample rate. In addition to the
			complexity savings, the compressed representations may induce a bias towards a temporal
			hierarchical modeling of the time series across the blocks that allows N-HiTS to exceed
			the performance of competing long-horizon forecasting models while requiring an order of
			magnitude lower computational complexity `),b(t.$$.fragment),s=c(".")},l(n){e=h(n,`The novel ideas from N-HiTS enable the possiblity of modeling increasingly long time
			horizons while keeping computational complexity low. They include the use of pooling
			layers that downsample the inputs to each block and upsampling layers that map a
			compressed representation of the forecast to the output sample rate. In addition to the
			complexity savings, the compressed representations may induce a bias towards a temporal
			hierarchical modeling of the time series across the blocks that allows N-HiTS to exceed
			the performance of competing long-horizon forecasting models while requiring an order of
			magnitude lower computational complexity `),k(t.$$.fragment,n),s=h(n,".")},m(n,i){m(n,e,i),I(t,n,i),m(n,s,i),a=!0},p:U,i(n){a||(y(t.$$.fragment,n),a=!0)},o(n){_(t.$$.fragment,n),a=!1},d(n){n&&(o(e),o(s)),M(t,n)}}}function Vo(l){let e;return{c(){e=c("Experiments")},l(t){e=h(t,"Experiments")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Fo(l){let e,t,s,a;return t=new K({props:{id:"gilpin"}}),{c(){e=c(`While Gilpin's experiments focus on testing 24 different time-series prediction models
			on over 130 different chaotic systems using a relatively narrow range of hyper
			parameters for tuning `),b(t.$$.fragment),s=c(`, my experiments aim to tune a single model,
			N-HiTS, on a single system, the Lorenz Attractor, to maximize its accuracy for a given,
			relatively long, fixed horizon (aka prediction window length). And more specifically, I
			aim not only to achieve a low average error on the test set but also to limit the
			worst-case error as much as possible, which will likely mean achieving a degree of
			predictive power over the most chaotic regions of the system. Is this a completely naive
			aspiration given what is known about chaotic systems? Maybe, but I'm not really sure
			yet, and either way this should be a fun learning experience...
		`)},l(n){e=h(n,`While Gilpin's experiments focus on testing 24 different time-series prediction models
			on over 130 different chaotic systems using a relatively narrow range of hyper
			parameters for tuning `),k(t.$$.fragment,n),s=h(n,`, my experiments aim to tune a single model,
			N-HiTS, on a single system, the Lorenz Attractor, to maximize its accuracy for a given,
			relatively long, fixed horizon (aka prediction window length). And more specifically, I
			aim not only to achieve a low average error on the test set but also to limit the
			worst-case error as much as possible, which will likely mean achieving a degree of
			predictive power over the most chaotic regions of the system. Is this a completely naive
			aspiration given what is known about chaotic systems? Maybe, but I'm not really sure
			yet, and either way this should be a fun learning experience...
		`)},m(n,i){m(n,e,i),I(t,n,i),m(n,s,i),a=!0},p:U,i(n){a||(y(t.$$.fragment,n),a=!0)},o(n){_(t.$$.fragment,n),a=!1},d(n){n&&(o(e),o(s)),M(t,n)}}}function Bo(l){let e;return{c(){e=c("Data Generation")},l(t){e=h(t,"Data Generation")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Uo(l){let e;return{c(){e=c("dysts")},l(t){e=h(t,"dysts")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Oo(l){let e;return{c(){e=c("IVP solver")},l(t){e=h(t,"IVP solver")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Wo(l){let e;return{c(){e=c("dysts")},l(t){e=h(t,"dysts")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Ko(l){let e,t="$dt$",s,a,n="$0.015$",i,r,p,d,A,D,u="$dt$",L,S,E,q="after",z,G="$dt$",Z,J,F,st,Y="$\\text{first_step} = 0.0001801$",O,V,W;return p=new B({props:{href:"https://github.com/williamgilpin/dysts",$$slots:{default:[Uo]},$$scope:{ctx:l}}}),A=new B({props:{href:"https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html",$$slots:{default:[Oo]},$$scope:{ctx:l}}}),F=new B({props:{href:"https://github.com/williamgilpin/dysts",$$slots:{default:[Wo]},$$scope:{ctx:l}}}),{c(){e=c("I begin with a horizon (prediction window) of 100 points, using a "),s=c(t),a=c(` of approximately
			`),i=c(n),r=c(" seconds per point (the default from "),b(p.$$.fragment),d=c(") to sample the solution produced by the "),b(A.$$.fragment),D=c(". Importantly, note that this "),L=c(u),S=c(` is only the one used for sampling the solution
			`),E=j("i"),E.textContent=q,z=c(`
			it is generated by the IVP solver. The actual `),Z=c(G),J=c(` used internally by the IVP solver
			can vary dynamically, but the initial target value used by `),b(F.$$.fragment),st=c(" is: "),O=c(Y),V=c(`.
		`)},l(N){e=h(N,"I begin with a horizon (prediction window) of 100 points, using a "),s=h(N,t),a=h(N,` of approximately
			`),i=h(N,n),r=h(N," seconds per point (the default from "),k(p.$$.fragment,N),d=h(N,") to sample the solution produced by the "),k(A.$$.fragment,N),D=h(N,". Importantly, note that this "),L=h(N,u),S=h(N,` is only the one used for sampling the solution
			`),E=P(N,"I",{"data-svelte-h":!0}),tt(E)!=="svelte-10nlrz4"&&(E.textContent=q),z=h(N,`
			it is generated by the IVP solver. The actual `),Z=h(N,G),J=h(N,` used internally by the IVP solver
			can vary dynamically, but the initial target value used by `),k(F.$$.fragment,N),st=h(N," is: "),O=h(N,Y),V=h(N,`.
		`)},m(N,C){m(N,e,C),m(N,s,C),m(N,a,C),m(N,i,C),m(N,r,C),I(p,N,C),m(N,d,C),I(A,N,C),m(N,D,C),m(N,L,C),m(N,S,C),m(N,E,C),m(N,z,C),m(N,Z,C),m(N,J,C),I(F,N,C),m(N,st,C),m(N,O,C),m(N,V,C),W=!0},p(N,C){const X={};C&256&&(X.$$scope={dirty:C,ctx:N}),p.$set(X);const et={};C&256&&(et.$$scope={dirty:C,ctx:N}),A.$set(et);const it={};C&256&&(it.$$scope={dirty:C,ctx:N}),F.$set(it)},i(N){W||(y(p.$$.fragment,N),y(A.$$.fragment,N),y(F.$$.fragment,N),W=!0)},o(N){_(p.$$.fragment,N),_(A.$$.fragment,N),_(F.$$.fragment,N),W=!1},d(N){N&&(o(e),o(s),o(a),o(i),o(r),o(d),o(D),o(L),o(S),o(E),o(z),o(Z),o(J),o(st),o(O),o(V)),M(p,N),M(A,N),M(F,N)}}}function Jo(l){let e;return{c(){e=c("Lyapunov exponent")},l(t){e=h(t,"Lyapunov exponent")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Yo(l){let e;return{c(){e=c("dysts")},l(t){e=h(t,"dysts")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Xo(l){let e;return{c(){e=c("Lyapunov time")},l(t){e=h(t,"Lyapunov time")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Zo(l){let e,t,s,a,n,i="$0.8917$",r,p,d,A,D="$1.121s$",u,L,S;return t=new B({props:{href:"https://en.wikipedia.org/wiki/Lyapunov_exponent",$$slots:{default:[Jo]},$$scope:{ctx:l}}}),a=new B({props:{href:"https://github.com/williamgilpin/dysts",$$slots:{default:[Yo]},$$scope:{ctx:l}}}),d=new B({props:{href:"https://en.wikipedia.org/wiki/Lyapunov_time",$$slots:{default:[Xo]},$$scope:{ctx:l}}}),{c(){e=c(`At this stage, it may also be worth mentioning one of the common metrics for measuring
			the average chaoticity of a system, the maximum
			`),b(t.$$.fragment),s=c(`.
			As reported in
			`),b(a.$$.fragment),n=c(`, the Lyapunov exponent
			for the Lorenz Attractor is approx. `),r=c(i),p=c(", and so the "),b(d.$$.fragment),A=c(` is approx.
			`),u=c(D),L=c(".")},l(E){e=h(E,`At this stage, it may also be worth mentioning one of the common metrics for measuring
			the average chaoticity of a system, the maximum
			`),k(t.$$.fragment,E),s=h(E,`.
			As reported in
			`),k(a.$$.fragment,E),n=h(E,`, the Lyapunov exponent
			for the Lorenz Attractor is approx. `),r=h(E,i),p=h(E,", and so the "),k(d.$$.fragment,E),A=h(E,` is approx.
			`),u=h(E,D),L=h(E,".")},m(E,q){m(E,e,q),I(t,E,q),m(E,s,q),I(a,E,q),m(E,n,q),m(E,r,q),m(E,p,q),I(d,E,q),m(E,A,q),m(E,u,q),m(E,L,q),S=!0},p(E,q){const z={};q&256&&(z.$$scope={dirty:q,ctx:E}),t.$set(z);const G={};q&256&&(G.$$scope={dirty:q,ctx:E}),a.$set(G);const Z={};q&256&&(Z.$$scope={dirty:q,ctx:E}),d.$set(Z)},i(E){S||(y(t.$$.fragment,E),y(a.$$.fragment,E),y(d.$$.fragment,E),S=!0)},o(E){_(t.$$.fragment,E),_(a.$$.fragment,E),_(d.$$.fragment,E),S=!1},d(E){E&&(o(e),o(s),o(n),o(r),o(p),o(A),o(u),o(L)),M(t,E),M(a,E),M(d,E)}}}function Qo(l){let e,t,s="on average",a,n="$e$",i,r,p="$1.121$",d,A,D="$\\frac{4}{3}$",u,L;return{c(){e=c("This tells us that, "),t=j("i"),t.textContent=s,a=c(`, the distance between any two trajectories from
			the Lorenz Attractor are expected to diverge by a factor of `),i=c(n),r=c(` after
			`),d=c(p),A=c(` seconds. Note that with these parameters, the horizon covers a time period of
			about
			`),u=c(D),L=c(`
			of the Lyapunov time.
		`)},l(S){e=h(S,"This tells us that, "),t=P(S,"I",{"data-svelte-h":!0}),tt(t)!=="svelte-ggx8py"&&(t.textContent=s),a=h(S,`, the distance between any two trajectories from
			the Lorenz Attractor are expected to diverge by a factor of `),i=h(S,n),r=h(S,` after
			`),d=h(S,p),A=h(S,` seconds. Note that with these parameters, the horizon covers a time period of
			about
			`),u=h(S,D),L=h(S,`
			of the Lyapunov time.
		`)},m(S,E){m(S,e,E),m(S,t,E),m(S,a,E),m(S,i,E),m(S,r,E),m(S,d,E),m(S,A,E),m(S,u,E),m(S,L,E)},p:U,d(S){S&&(o(e),o(t),o(a),o(i),o(r),o(d),o(A),o(u),o(L))}}}function tr(l){let e,t="$[-9.79, -15.04, 20.53]$",s,a,n="$[0.99,1.01]$",i,r;return{c(){e=c(`The train and test sets are comprised of many trajectories with initial conditions all
			centered at approx. `),s=c(t),a=c(` and multiplied by a random perturbation
			uniformly sampled from the interval `),i=c(n),r=c(".")},l(p){e=h(p,`The train and test sets are comprised of many trajectories with initial conditions all
			centered at approx. `),s=h(p,t),a=h(p,` and multiplied by a random perturbation
			uniformly sampled from the interval `),i=h(p,n),r=h(p,".")},m(p,d){m(p,e,d),m(p,s,d),m(p,a,d),m(p,i,d),m(p,r,d)},p:U,d(p){p&&(o(e),o(s),o(a),o(i),o(r))}}}function er(l){let e,t="$3*100 = 300$",s,a,n="$3 * (500 + 100) = 1800$",i,r;return{c(){e=c(`The input to the N-HiTs model is a lookback window of the previous series values whose
			length is typically some multiple of the horizon window. I went with the default value
			from the N-HiTS paper of 5 times the horizon window length, or 500 points, making each
			training sample a total of 600 points. (Note that because N-HiTs is a univariate model,
			while the Lorenz System is three-dimensional, the data points must be flattened into one
			dimension. Therefore, the horizon window length is actually `),s=c(t),a=c(`, and each
			training sample's length is `),i=c(n),r=c(").")},l(p){e=h(p,`The input to the N-HiTs model is a lookback window of the previous series values whose
			length is typically some multiple of the horizon window. I went with the default value
			from the N-HiTS paper of 5 times the horizon window length, or 500 points, making each
			training sample a total of 600 points. (Note that because N-HiTs is a univariate model,
			while the Lorenz System is three-dimensional, the data points must be flattened into one
			dimension. Therefore, the horizon window length is actually `),s=h(p,t),a=h(p,`, and each
			training sample's length is `),i=h(p,n),r=h(p,").")},m(p,d){m(p,e,d),m(p,s,d),m(p,a,d),m(p,i,d),m(p,r,d)},p:U,d(p){p&&(o(e),o(s),o(a),o(i),o(r))}}}function nr(l){let e,t=`$10,000 - 600 +
		1 = 9401$`,s,a;return{c(){e=c(`I choose, somewhat arbitrarily, to generate 10,000 points per series, and in order to
			increase data efficiency, I select each training sample by sliding the 600-point window
			along the series with a one-point stride. Each series, therefore, contributes `),s=c(t),a=c(` training samples. For the initial experiment, I generate 25 series with unique initial conditions,
			and train on 19 of them, and hold out 3 series for validation and 3 series for testing.`)},l(n){e=h(n,`I choose, somewhat arbitrarily, to generate 10,000 points per series, and in order to
			increase data efficiency, I select each training sample by sliding the 600-point window
			along the series with a one-point stride. Each series, therefore, contributes `),s=h(n,t),a=h(n,` training samples. For the initial experiment, I generate 25 series with unique initial conditions,
			and train on 19 of them, and hold out 3 series for validation and 3 series for testing.`)},m(n,i){m(n,e,i),m(n,s,i),m(n,a,i)},p:U,d(n){n&&(o(e),o(s),o(a))}}}function sr(l){let e;return{c(){e=c("Model 1")},l(t){e=h(t,"Model 1")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function ar(l){let e;return{c(){e=c("The full set of N-HiTS hyperparameters for the first model configuration is:")},l(t){e=h(t,"The full set of N-HiTS hyperparameters for the first model configuration is:")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function ir(l){let e,t,s,a,n,i;return t=new K({props:{id:"challu"}}),a=new K({props:{id:"gilpin"}}),{c(){e=c("The model is optimized with MAE loss, consistent with the default loss from "),b(t.$$.fragment),s=c(`. For evaluation, I use the symmetric mean absolute percentage error (sMAPE) as
			defined in
			`),b(a.$$.fragment),n=c(":")},l(r){e=h(r,"The model is optimized with MAE loss, consistent with the default loss from "),k(t.$$.fragment,r),s=h(r,`. For evaluation, I use the symmetric mean absolute percentage error (sMAPE) as
			defined in
			`),k(a.$$.fragment,r),n=h(r,":")},m(r,p){m(r,e,p),I(t,r,p),m(r,s,p),I(a,r,p),m(r,n,p),i=!0},p:U,i(r){i||(y(t.$$.fragment,r),y(a.$$.fragment,r),i=!0)},o(r){_(t.$$.fragment,r),_(a.$$.fragment,r),i=!1},d(r){r&&(o(e),o(s),o(n)),M(t,r),M(a,r)}}}function or(l){let e;return{c(){e=c(`In this formulation, sMAPE is bound to the interval [0, 200]. The distribution of
			average window errors and its CDF on the test set are shown below. Note that the left y
			axis is log-scaled.`)},l(t){e=h(t,`In this formulation, sMAPE is bound to the interval [0, 200]. The distribution of
			average window errors and its CDF on the test set are shown below. Note that the left y
			axis is log-scaled.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function rr(l){let e;return{c(){e=c("Model 1 - sMAPE error distribution on the test set")},l(t){e=h(t,"Model 1 - sMAPE error distribution on the test set")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function lr(l){let e;return{c(){e=c(`To gain a more intuitive understanding of the magnitude of these errors, we can plot
			individual window predictions against the references:`)},l(t){e=h(t,`To gain a more intuitive understanding of the magnitude of these errors, we can plot
			individual window predictions against the references:`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function fr(l){let e;return{c(){e=c(`Samples of three different 100-point predictions from Model 1 with small, medium,
				and large sMAPE errors`)},l(t){e=h(t,`Samples of three different 100-point predictions from Model 1 with small, medium,
				and large sMAPE errors`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function cr(l){let e;return{c(){e=c(`One interesting observation in all three graphs is that there appears to be a kind of
			"point of divergence" on the prediction before which the average error is very low and
			after which the error grows quickly. In the first graph, this point is about in the
			middle of the prediction, in the second it is maybe one third of the way into the
			prediction, and in the third it is near the beginning. If we look at the predictions of
			adjacent windows (see below animation), we see that the behavior at this point is
			consisent across the windows, indicating that there is something about the system's
			behavior in this region that is very difficult for this model to fit, regardless of its
			alignment within the prediction window.`)},l(t){e=h(t,`One interesting observation in all three graphs is that there appears to be a kind of
			"point of divergence" on the prediction before which the average error is very low and
			after which the error grows quickly. In the first graph, this point is about in the
			middle of the prediction, in the second it is maybe one third of the way into the
			prediction, and in the third it is near the beginning. If we look at the predictions of
			adjacent windows (see below animation), we see that the behavior at this point is
			consisent across the windows, indicating that there is something about the system's
			behavior in this region that is very difficult for this model to fit, regardless of its
			alignment within the prediction window.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function hr(l){let e;return{c(){e=c(`The behavior of the model near the origin, which is a critical point of the system,
				for an especially challenging case. In contrast to all other regions of this
				trajectory, the model seems highly uncertain of how the trajectory will evolve
				shortly after passing near the origin.`)},l(t){e=h(t,`The behavior of the model near the origin, which is a critical point of the system,
				for an especially challenging case. In contrast to all other regions of this
				trajectory, the model seems highly uncertain of how the trajectory will evolve
				shortly after passing near the origin.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function ur(l){let e;return{c(){e=c("critical points")},l(t){e=h(t,"critical points")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function mr(l){let e,t,s,a,n,i,r,p;return t=new B({props:{href:"https://en.wikipedia.org/wiki/Critical_point_(mathematics)",$$slots:{default:[ur]},$$scope:{ctx:l}}}),a=new K({props:{id:"osinga"}}),i=new K({props:{id:"osinga"}}),{c(){e=c(`For anyone familiar with dynamical systems theory, it won't be a surprise that this
			point coincides with one of the three `),b(t.$$.fragment),s=c(` of the Lorenz system--in this case, the origin. And in this parameterization, the origin
			is known to be a saddle point comprised of the intersection of a stable 2D manifold and an
			unstable 1D manifold. "Stable" here means that trajectories near the critical point tend
			to move towards it even if they are perturbed slightly away from it by other forces, while
			"unstable" implies the opposite. (See `),b(a.$$.fragment),n=c(` for some excellent visualizations
			of these manifolds.) Near the origin, the unstable manifold is a line that is approximately
			perpendicular to the Z axis and parallel to the lengthwise orientation of the Attractor,
			which is why the trajectories always diverge at the near-90-degree angles that we see in
			the animations as they approach the origin. And the (incredibly complex) topography of the
			stable 2D manifold determines towards which of the other two critical points a trajectory
			will be deflected `),b(i.$$.fragment),r=c(`. In fact, I would tenatively conclude that the
			primary goal of the neural network is to learn the topography of the origin's stable 2D
			manifold; since this manifold defines a boundary across which trajectories can never
			pass, we can confine the past and future path of any trajectory based on the boundaries
			of this manifold.
		`)},l(d){e=h(d,`For anyone familiar with dynamical systems theory, it won't be a surprise that this
			point coincides with one of the three `),k(t.$$.fragment,d),s=h(d,` of the Lorenz system--in this case, the origin. And in this parameterization, the origin
			is known to be a saddle point comprised of the intersection of a stable 2D manifold and an
			unstable 1D manifold. "Stable" here means that trajectories near the critical point tend
			to move towards it even if they are perturbed slightly away from it by other forces, while
			"unstable" implies the opposite. (See `),k(a.$$.fragment,d),n=h(d,` for some excellent visualizations
			of these manifolds.) Near the origin, the unstable manifold is a line that is approximately
			perpendicular to the Z axis and parallel to the lengthwise orientation of the Attractor,
			which is why the trajectories always diverge at the near-90-degree angles that we see in
			the animations as they approach the origin. And the (incredibly complex) topography of the
			stable 2D manifold determines towards which of the other two critical points a trajectory
			will be deflected `),k(i.$$.fragment,d),r=h(d,`. In fact, I would tenatively conclude that the
			primary goal of the neural network is to learn the topography of the origin's stable 2D
			manifold; since this manifold defines a boundary across which trajectories can never
			pass, we can confine the past and future path of any trajectory based on the boundaries
			of this manifold.
		`)},m(d,A){m(d,e,A),I(t,d,A),m(d,s,A),I(a,d,A),m(d,n,A),I(i,d,A),m(d,r,A),p=!0},p(d,A){const D={};A&256&&(D.$$scope={dirty:A,ctx:d}),t.$set(D)},i(d){p||(y(t.$$.fragment,d),y(a.$$.fragment,d),y(i.$$.fragment,d),p=!0)},o(d){_(t.$$.fragment,d),_(a.$$.fragment,d),_(i.$$.fragment,d),p=!1},d(d){d&&(o(e),o(s),o(n),o(r)),M(t,d),M(a,d),M(i,d)}}}function pr(l){let e,t="$f(t) = \\exp(\\lambda t)x_0$",s,a,n="$\\lambda$",i,r,p="$x_0$",d,A,D="$11.8$",u,L;return{c(){e=c(`We can estimate how unstable the 1D manifold is by calculating the eigenvalues of the
			Jacobian matrix of the system at the origin and assuming the dynamics are approximately
			linear in this region. When we do this, we get three eigenvalues, two of which have
			negative real components and are associated with the stable 2D manifold, and the third
			which has positive real component and is associated with the unstable 1D manifold. The
			dynamics along the manifolds near the origin can be approximated by the expression `),s=c(t),a=c(`,
			where `),i=c(n),r=c(" equals the eigenvalue and "),d=c(p),A=c(` is the starting point. For the Lorenz
			Attractor, the eigenvalue associated with the unstable manifold is `),u=c(D),L=c(`, so
			trajectories will be rapidly deflected away from the origin along the unstable manifold,
			as we see in the below animation:`)},l(S){e=h(S,`We can estimate how unstable the 1D manifold is by calculating the eigenvalues of the
			Jacobian matrix of the system at the origin and assuming the dynamics are approximately
			linear in this region. When we do this, we get three eigenvalues, two of which have
			negative real components and are associated with the stable 2D manifold, and the third
			which has positive real component and is associated with the unstable 1D manifold. The
			dynamics along the manifolds near the origin can be approximated by the expression `),s=h(S,t),a=h(S,`,
			where `),i=h(S,n),r=h(S," equals the eigenvalue and "),d=h(S,p),A=h(S,` is the starting point. For the Lorenz
			Attractor, the eigenvalue associated with the unstable manifold is `),u=h(S,D),L=h(S,`, so
			trajectories will be rapidly deflected away from the origin along the unstable manifold,
			as we see in the below animation:`)},m(S,E){m(S,e,E),m(S,s,E),m(S,a,E),m(S,i,E),m(S,r,E),m(S,d,E),m(S,A,E),m(S,u,E),m(S,L,E)},p:U,d(S){S&&(o(e),o(s),o(a),o(i),o(r),o(d),o(A),o(u),o(L))}}}function dr(l){let e;return{c(){e=c(`The trajectories from the training set all begin at nearly the same point but
				quickly diverge as they approach the critical point at the origin.`)},l(t){e=h(t,`The trajectories from the training set all begin at nearly the same point but
				quickly diverge as they approach the critical point at the origin.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function $r(l){let e;return{c(){e=c(`Given all of this background, it is now unsurprising that the model is struggling to
			predict the behavior of the system near the origin. But we should also note that the
			model does quite well at predicting basically every other region of the system. We just
			have to figure out a way to improve the predictions near the origin, and then we should
			have a model with an overall very robust representation of the Lorenz Attractor. As this
			model and its training set are relatively modest in size, the next most obvious step to
			try is to significantly increase both the amount of training data and the model's
			capacity, and see if those changes alone are enough to resolve the weaknesses of Model
			1.`)},l(t){e=h(t,`Given all of this background, it is now unsurprising that the model is struggling to
			predict the behavior of the system near the origin. But we should also note that the
			model does quite well at predicting basically every other region of the system. We just
			have to figure out a way to improve the predictions near the origin, and then we should
			have a model with an overall very robust representation of the Lorenz Attractor. As this
			model and its training set are relatively modest in size, the next most obvious step to
			try is to significantly increase both the amount of training data and the model's
			capacity, and see if those changes alone are enough to resolve the weaknesses of Model
			1.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function gr(l){let e;return{c(){e=c("Model 2")},l(t){e=h(t,"Model 2")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function wr(l){let e;return{c(){e=c(`For the next model, I increased the number of unique initial conditions from 25 to
			10000, and held out 100 for validation and 200 for testing, leaving 9700 unique initial
			conditions, each of length 10,000 points, or about 150 seconds, in the training set. I
			also expanded the range of hyperparameters for tuning to include significantly larger
			models, both in depth and width. After tuning, I arrived at the following settings:`)},l(t){e=h(t,`For the next model, I increased the number of unique initial conditions from 25 to
			10000, and held out 100 for validation and 200 for testing, leaving 9700 unique initial
			conditions, each of length 10,000 points, or about 150 seconds, in the training set. I
			also expanded the range of hyperparameters for tuning to include significantly larger
			models, both in depth and width. After tuning, I arrived at the following settings:`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function vr(l){let e;return{c(){e=c("Model 2 vs Model 1 - sMAPE error distribution.")},l(t){e=h(t,"Model 2 vs Model 1 - sMAPE error distribution.")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function yr(l){let e;return{c(){e=c(`From the plot, we see a significant increase in the first bin and a reduction in every
			subsequent bin of the per-window error histogram relative to Model 1, so the larger
			dataset and new hyperparameter tunings have a definite and significant positive impact.
			99% of windows from Model 2 have a sMAPE less than 6, compared to only 74% for Model 1,
			and 99.9% have a sMAPE less than 40, compared to 98% for Model 1.`)},l(t){e=h(t,`From the plot, we see a significant increase in the first bin and a reduction in every
			subsequent bin of the per-window error histogram relative to Model 1, so the larger
			dataset and new hyperparameter tunings have a definite and significant positive impact.
			99% of windows from Model 2 have a sMAPE less than 6, compared to only 74% for Model 1,
			and 99.9% have a sMAPE less than 40, compared to 98% for Model 1.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function _r(l){let e;return{c(){e=c(`There are, however, still a handful of windows with very large sMAPE errors. We can
			visualize these errors slightly differently to get a better sense of how they are
			distributed within and across the test series:`)},l(t){e=h(t,`There are, however, still a handful of windows with very large sMAPE errors. We can
			visualize these errors slightly differently to get a better sense of how they are
			distributed within and across the test series:`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function br(l){let e;return{c(){e=c("Model 2 - sMAPE errors per series per window in the test set.")},l(t){e=h(t,"Model 2 - sMAPE errors per series per window in the test set.")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function kr(l){let e;return{c(){e=c(`We see that very large errors occur quite rarely and briefly, with the predictions
			spending most of the time near the ground truth. Let's check the animation for one of
			the large spikes with a sMAPE greater than 100:`)},l(t){e=h(t,`We see that very large errors occur quite rarely and briefly, with the predictions
			spending most of the time near the ground truth. Let's check the animation for one of
			the large spikes with a sMAPE greater than 100:`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Ir(l){let e;return{c(){e=c(`Model 2 - a trajectory with one of the largest sMAPE errors from the test set. DFO =
				'distance from origin'`)},l(t){e=h(t,`Model 2 - a trajectory with one of the largest sMAPE errors from the test set. DFO =
				'distance from origin'`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Mr(l){let e;return{c(){e=c(`Not surprisingly, this trajectory passes very close to the origin, and we immediately
			see how similar this failure case is to the one from Model 1. Despite the average
			improvement across all error magnitudes, has the model's ability to predict the behavior
			near the unstable origin actually improved significantly relative to Model 1? Let's
			check:`)},l(t){e=h(t,`Not surprisingly, this trajectory passes very close to the origin, and we immediately
			see how similar this failure case is to the one from Model 1. Despite the average
			improvement across all error magnitudes, has the model's ability to predict the behavior
			near the unstable origin actually improved significantly relative to Model 1? Let's
			check:`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Ar(l){let e,t="$n$",s,a,n="$n-1$",i,r,p="$n+1$",d,A;return{c(){e=c(`Each local minimum distance from the origin on the ground truth trajectories is
				calculated, and the corresponding maximum sMAPE error among the windows that
				included the minimum in its target is shown. A local minimum is defined as a point
				at time `),s=c(t),a=c(`
				that is closer to the origin than the points at `),i=c(n),r=c(" and "),d=c(p),A=c(".")},l(D){e=h(D,`Each local minimum distance from the origin on the ground truth trajectories is
				calculated, and the corresponding maximum sMAPE error among the windows that
				included the minimum in its target is shown. A local minimum is defined as a point
				at time `),s=h(D,t),a=h(D,`
				that is closer to the origin than the points at `),i=h(D,n),r=h(D," and "),d=h(D,p),A=h(D,".")},m(D,u){m(D,e,u),m(D,s,u),m(D,a,u),m(D,i,u),m(D,r,u),m(D,d,u),m(D,A,u)},p:U,d(D){D&&(o(e),o(s),o(a),o(i),o(r),o(d),o(A))}}}function Er(l){let e;return{c(){e=c(`As we can clearly see from the plot, Model 2 is able to predict points that are closer
			to the origin more accurately than Model 1. So although Model 2 is not able to avoid
			catastraphic failure for all points, it has indeed reduced the number of points for
			which these failures occur.`)},l(t){e=h(t,`As we can clearly see from the plot, Model 2 is able to predict points that are closer
			to the origin more accurately than Model 1. So although Model 2 is not able to avoid
			catastraphic failure for all points, it has indeed reduced the number of points for
			which these failures occur.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Tr(l){let e,t="$dt$",s,a,n="$dt$",i,r,p="$\\approx0.015$",d,A,D="$\\approx0.003$",u,L,S="$\\approx1.5$",E,q;return{c(){e=c(`So we've drastically increased both model capacity and dataset size, and we have only
			achieved marginal improvement on the most chaotic trajectories. To continue to make
			progress, we probably need to try a different approach. One idea is to increase the
			temporal resolution of the model by using a smaller `),s=c(t),a=c(` to generate our data points.
			So far we've used a `),i=c(n),r=c(" of "),d=c(p),A=c(`. Let's try reducing that by a factor
			of 5 to `),u=c(D),L=c(`, and in order to keep the prediction task equally difficult,
			we'll also increase the horizon window, and lookback window, by a factor of 5 to 500 and
			2500 respectively, so that the total amount of time being predicted is still `),E=c(S),q=c(`
			seconds. We'll call this Model 3.`)},l(z){e=h(z,`So we've drastically increased both model capacity and dataset size, and we have only
			achieved marginal improvement on the most chaotic trajectories. To continue to make
			progress, we probably need to try a different approach. One idea is to increase the
			temporal resolution of the model by using a smaller `),s=h(z,t),a=h(z,` to generate our data points.
			So far we've used a `),i=h(z,n),r=h(z," of "),d=h(z,p),A=h(z,`. Let's try reducing that by a factor
			of 5 to `),u=h(z,D),L=h(z,`, and in order to keep the prediction task equally difficult,
			we'll also increase the horizon window, and lookback window, by a factor of 5 to 500 and
			2500 respectively, so that the total amount of time being predicted is still `),E=h(z,S),q=h(z,`
			seconds. We'll call this Model 3.`)},m(z,G){m(z,e,G),m(z,s,G),m(z,a,G),m(z,i,G),m(z,r,G),m(z,d,G),m(z,A,G),m(z,u,G),m(z,L,G),m(z,E,G),m(z,q,G)},p:U,d(z){z&&(o(e),o(s),o(a),o(i),o(r),o(d),o(A),o(u),o(L),o(E),o(q))}}}function xr(l){let e;return{c(){e=c("Model 3")},l(t){e=h(t,"Model 3")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function zr(l){let e;return{c(){e=c("The new hyperparameters for Model 3 are:")},l(t){e=h(t,"The new hyperparameters for Model 3 are:")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function jr(l){let e;return{c(){e=c("FSDP Strategy")},l(t){e=h(t,"FSDP Strategy")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Pr(l){let e,t,s,a,n,i;return a=new B({props:{href:"https://lightning.ai/docs/pytorch/stable/advanced/model_parallel/fsdp.html",$$slots:{default:[jr]},$$scope:{ctx:l}}}),{c(){e=c("A sidenote on the practicality of training this model: "),t=j("p"),s=c(`Although we have not increased the number of parameters relative to Model 2, by
				increasing the input size and horizon length by a factor of 5, we have significantly
				increased the memory requirement for training this model. Now in order to fit the
				model on two GPUs with 16 GB of RAM each, I have to use Lightning's `),b(a.$$.fragment),n=c(` to distribute the model across both GPUs in order to get the per-GPU memory requirement
				to be just a hair under 16 GB. This also means that the model trains significantly more
				slowly, taking about 40 hours to converge, compared to about 16 hours for Model 2.`),this.h()},l(r){e=h(r,"A sidenote on the practicality of training this model: "),t=P(r,"P",{class:!0});var p=R(t);s=h(p,`Although we have not increased the number of parameters relative to Model 2, by
				increasing the input size and horizon length by a factor of 5, we have significantly
				increased the memory requirement for training this model. Now in order to fit the
				model on two GPUs with 16 GB of RAM each, I have to use Lightning's `),k(a.$$.fragment,p),n=h(p,` to distribute the model across both GPUs in order to get the per-GPU memory requirement
				to be just a hair under 16 GB. This also means that the model trains significantly more
				slowly, taking about 40 hours to converge, compared to about 16 hours for Model 2.`),p.forEach(o),this.h()},h(){v(t,"class","ms-8")},m(r,p){m(r,e,p),m(r,t,p),$(t,s),I(a,t,null),$(t,n),i=!0},p(r,p){const d={};p&256&&(d.$$scope={dirty:p,ctx:r}),a.$set(d)},i(r){i||(y(a.$$.fragment,r),i=!0)},o(r){_(a.$$.fragment,r),i=!1},d(r){r&&(o(e),o(t)),M(a)}}}function Lr(l){let e;return{c(){e=c("Model 3 vs. Model 2 - sMAPE error distribution.")},l(t){e=h(t,"Model 3 vs. Model 2 - sMAPE error distribution.")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Sr(l){let e;return{c(){e=c(`The maximum-error trajectory from the test set for Model 3. Although there is still
				lots of room for improvement, the predictions now at least roughly track the general
				contour of the ground truth.`)},l(t){e=h(t,`The maximum-error trajectory from the test set for Model 3. Although there is still
				lots of room for improvement, the predictions now at least roughly track the general
				contour of the ground truth.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Dr(l){let e,t="$dt \\approx 0.015$",s,a,n="$dt \\approx 0.003$",i,r;return{c(){e=c(`Based on the results of Model 3, we can conclude that a primary limiting factor with
			previous models was the temporal resolution of the trajectory's history; the information
			required to make an accurate prediction for the most challenging trajectories is
			apparently not contained in trajectories with a sample period of `),s=c(t),a=c(`,
			but much more of it is contained in trajectories with a sample period of `),i=c(n),r=c(".")},l(p){e=h(p,`Based on the results of Model 3, we can conclude that a primary limiting factor with
			previous models was the temporal resolution of the trajectory's history; the information
			required to make an accurate prediction for the most challenging trajectories is
			apparently not contained in trajectories with a sample period of `),s=h(p,t),a=h(p,`,
			but much more of it is contained in trajectories with a sample period of `),i=h(p,n),r=h(p,".")},m(p,d){m(p,e,d),m(p,s,d),m(p,a,d),m(p,i,d),m(p,r,d)},p:U,d(p){p&&(o(e),o(s),o(a),o(i),o(r))}}}function Nr(l){let e;return{c(){e=c("Autoregressive Prediction")},l(t){e=h(t,"Autoregressive Prediction")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Rr(l){let e,t="$\\approx 7.5$",s,a;return{c(){e=c("Now that we have a model that adequately approximates the ODE given the last "),s=c(t),a=c(`
			seconds of the IVP solver's output, the next test is to measure how well the model continues
			to predict the trajectory given its own past predictions. To do this, for each trajectory
			in the test set, we will begin by using the first 2500 points to produce the model's prediction
			for points 2501-3000. Then we'll feed those 500 points back into the input to predict points
			3001-3500, and continue in this way for all 10,000 points in each trajectory. Then we can
			compare how closely the predicted trajectories match the ones produced by the IVP solver.
		`)},l(n){e=h(n,"Now that we have a model that adequately approximates the ODE given the last "),s=h(n,t),a=h(n,`
			seconds of the IVP solver's output, the next test is to measure how well the model continues
			to predict the trajectory given its own past predictions. To do this, for each trajectory
			in the test set, we will begin by using the first 2500 points to produce the model's prediction
			for points 2501-3000. Then we'll feed those 500 points back into the input to predict points
			3001-3500, and continue in this way for all 10,000 points in each trajectory. Then we can
			compare how closely the predicted trajectories match the ones produced by the IVP solver.
		`)},m(n,i){m(n,e,i),m(n,s,i),m(n,a,i)},p:U,d(n){n&&(o(e),o(s),o(a))}}}function qr(l){let e,t="$\\approx7.2$",s,a;return{c(){e=c("When we do this, we find that Model 3 is, on average, able to predict the first "),s=c(t),a=c(`
			seconds of the trajectory before it begins to diverge significantly from the reference (I
			arrived at this by calculating the mean time at which the maximum L2 distance between corresponding
			points on the trajectories exceeds 3). But we also note that, although there are clearly
			visible differences between the reference and the prediction, the full 10,000-point trajectories
			that Model 3 predicts are, to the naked eye at least, more or less indistinguishable from
			the typical trajectories of the Lorenz Attractor. In other words, they look like entirely
			plausible trajectories even if they eventually diverge significantly from the ones produced
			by the IVP solver for the same initial conditions.`)},l(n){e=h(n,"When we do this, we find that Model 3 is, on average, able to predict the first "),s=h(n,t),a=h(n,`
			seconds of the trajectory before it begins to diverge significantly from the reference (I
			arrived at this by calculating the mean time at which the maximum L2 distance between corresponding
			points on the trajectories exceeds 3). But we also note that, although there are clearly
			visible differences between the reference and the prediction, the full 10,000-point trajectories
			that Model 3 predicts are, to the naked eye at least, more or less indistinguishable from
			the typical trajectories of the Lorenz Attractor. In other words, they look like entirely
			plausible trajectories even if they eventually diverge significantly from the ones produced
			by the IVP solver for the same initial conditions.`)},m(n,i){m(n,e,i),m(n,s,i),m(n,a,i)},p:U,d(n){n&&(o(e),o(s),o(a))}}}function Gr(l){let e;return{c(){e=c(`Comparison of trajectories generated by the IVP solver (left) and auto-regressively
				generated by Model 3 (right). Each row uses the same initial conditions.`)},l(t){e=h(t,`Comparison of trajectories generated by the IVP solver (left) and auto-regressively
				generated by Model 3 (right). Each row uses the same initial conditions.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Hr(l){let e;return{c(){e=c("shadowing lemma")},l(t){e=h(t,"shadowing lemma")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Cr(l){let e,t,s,a;return t=new B({props:{href:"https://en.wikipedia.org/wiki/Shadowing_lemma",$$slots:{default:[Hr]},$$scope:{ctx:l}}}),{c(){e=c(`Is there a way to confirm this observation more rigorously than with the eye test
			alone? I'm not sure, and I'll have to leave that question for future work. But it's also
			crucial to note that different IVP solvers also produce diverging trajectories in much
			the same manner as this. In fact, all numerical solutions to chaotic equations are known
			to diverge from the true solution due to the rounding error introduced by finite
			precision. The `),b(t.$$.fragment),s=c(` tells us that, in spite of this, the trajectories produced by IVP solvers still remain
			arbitrarily close to real trajectories from the ODE even if they do not exactly represent
			the ones that would be produced by the given initial conditions.
		`)},l(n){e=h(n,`Is there a way to confirm this observation more rigorously than with the eye test
			alone? I'm not sure, and I'll have to leave that question for future work. But it's also
			crucial to note that different IVP solvers also produce diverging trajectories in much
			the same manner as this. In fact, all numerical solutions to chaotic equations are known
			to diverge from the true solution due to the rounding error introduced by finite
			precision. The `),k(t.$$.fragment,n),s=h(n,` tells us that, in spite of this, the trajectories produced by IVP solvers still remain
			arbitrarily close to real trajectories from the ODE even if they do not exactly represent
			the ones that would be produced by the given initial conditions.
		`)},m(n,i){m(n,e,i),I(t,n,i),m(n,s,i),a=!0},p(n,i){const r={};i&256&&(r.$$scope={dirty:i,ctx:n}),t.$set(r)},i(n){a||(y(t.$$.fragment,n),a=!0)},o(n){_(t.$$.fragment,n),a=!1},d(n){n&&(o(e),o(s)),M(t,n)}}}function Vr(l){let e;return{c(){e=c("dysts")},l(t){e=h(t,"dysts")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Fr(l){let e;return{c(){e=c("Radau")},l(t){e=h(t,"Radau")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Br(l){let e;return{c(){e=c("RK45")},l(t){e=h(t,"RK45")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Ur(l){let e,t,s,a,n,i,r,p;return t=new B({props:{href:"https://github.com/williamgilpin/dysts",$$slots:{default:[Vr]},$$scope:{ctx:l}}}),a=new B({props:{href:"https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.Radau.html",$$slots:{default:[Fr]},$$scope:{ctx:l}}}),i=new B({props:{href:"https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.RK45.html#scipy.integrate.RK45",$$slots:{default:[Br]},$$scope:{ctx:l}}}),{c(){e=c(`In light of this, another way to evaluate the autoregressive output of the model is to
			compare it with the output from a different IVP solver with similar error constraints. `),b(t.$$.fragment),s=c(" uses the "),b(a.$$.fragment),n=c(" solver by default, and this is what I used to generate the dataset. "),b(i.$$.fragment),r=c(` has similar error constraints to Radau, so let's compare the autoregressive output against
			Radau relative to RK45's output against Radau:`)},l(d){e=h(d,`In light of this, another way to evaluate the autoregressive output of the model is to
			compare it with the output from a different IVP solver with similar error constraints. `),k(t.$$.fragment,d),s=h(d," uses the "),k(a.$$.fragment,d),n=h(d," solver by default, and this is what I used to generate the dataset. "),k(i.$$.fragment,d),r=h(d,` has similar error constraints to Radau, so let's compare the autoregressive output against
			Radau relative to RK45's output against Radau:`)},m(d,A){m(d,e,A),I(t,d,A),m(d,s,A),I(a,d,A),m(d,n,A),I(i,d,A),m(d,r,A),p=!0},p(d,A){const D={};A&256&&(D.$$scope={dirty:A,ctx:d}),t.$set(D);const u={};A&256&&(u.$$scope={dirty:A,ctx:d}),a.$set(u);const L={};A&256&&(L.$$scope={dirty:A,ctx:d}),i.$set(L)},i(d){p||(y(t.$$.fragment,d),y(a.$$.fragment,d),y(i.$$.fragment,d),p=!0)},o(d){_(t.$$.fragment,d),_(a.$$.fragment,d),_(i.$$.fragment,d),p=!1},d(d){d&&(o(e),o(s),o(n),o(r)),M(t,d),M(a,d),M(i,d)}}}function Or(l){let e;return{c(){e=c("solve_ivp")},l(t){e=h(t,"solve_ivp")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Wr(l){let e,t,s,a;return t=new B({props:{href:"https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html",$$slots:{default:[Or]},$$scope:{ctx:l}}}),{c(){e=c(`Comparing the mean absolute error per timestep between Radau and Model 3 (blue) and
				Radua and RK45 (orange). The error is averaged across 200 different trajectories.
				Scipy's `),b(t.$$.fragment),s=c(" is used to produce the IVP solver outputs.")},l(n){e=h(n,`Comparing the mean absolute error per timestep between Radau and Model 3 (blue) and
				Radua and RK45 (orange). The error is averaged across 200 different trajectories.
				Scipy's `),k(t.$$.fragment,n),s=h(n," is used to produce the IVP solver outputs.")},m(n,i){m(n,e,i),I(t,n,i),m(n,s,i),a=!0},p(n,i){const r={};i&256&&(r.$$scope={dirty:i,ctx:n}),t.$set(r)},i(n){a||(y(t.$$.fragment,n),a=!0)},o(n){_(t.$$.fragment,n),a=!1},d(n){n&&(o(e),o(s)),M(t,n)}}}function Kr(l){let e;return{c(){e=c(`So we can say that the model is approximating the output of Radau more closely than
			another high-quality IVP solver. Ultimately, all three solvers diverge chaotically from
			each other, but in the short term, Model 3 remains closer to Radau than RK45. From this
			I tenatively conclude that the model is an effective IVP solver of the Lorenz Attractor.`)},l(t){e=h(t,`So we can say that the model is approximating the output of Radau more closely than
			another high-quality IVP solver. Ultimately, all three solvers diverge chaotically from
			each other, but in the short term, Model 3 remains closer to Radau than RK45. From this
			I tenatively conclude that the model is an effective IVP solver of the Lorenz Attractor.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Jr(l){let e;return{c(){e=c("Discussion")},l(t){e=h(t,"Discussion")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Yr(l){let e,t,s,a,n,i="$5H$",r,p,d="$H$",A,D,u;return t=new K({props:{id:"gilpin"}}),a=new K({props:{id:"challu"}}),{c(){e=c("Inspired by recent research ("),b(t.$$.fragment),s=c(`) that supports the potential for
			generic neural architectures to match or exceed the performance of domain-specific
			models at the task of predicting chaotic systems, this project demonstrated the strong
			potential of at least one generic neural architecture (`),b(a.$$.fragment),n=c(`) to
			qualitatively match the performance of state-of-the-art IVP solvers, such as Radau, at
			integrating the ODE for at least one specific system--Lorenz--using only examples of
			solutions, with no explicit representation of the underlying ODE, to build up a model of
			the entire dynamics of the system. Given `),r=c(i),p=c(` points of an initial trajectory and at
			a high enough temporal resolution, the neural model demonstrated the ability to predict the
			subsequent `),A=c(d),D=c(` outputs of the Radau solver with, in most cases, high accuracy, and in
			the worst case, marginal accuracy, for all trajectories in a test set that uniformly sampled
			the phase space of the system. When used autoregressively, the model demonstrated the potential
			to generate arbitrarily long trajectories that are visually indistinguishable from typical
			trajectories of the system and that match the output of the Radau solver at least as well
			as other state-of-the-art IVP solvers such as RK45.`)},l(L){e=h(L,"Inspired by recent research ("),k(t.$$.fragment,L),s=h(L,`) that supports the potential for
			generic neural architectures to match or exceed the performance of domain-specific
			models at the task of predicting chaotic systems, this project demonstrated the strong
			potential of at least one generic neural architecture (`),k(a.$$.fragment,L),n=h(L,`) to
			qualitatively match the performance of state-of-the-art IVP solvers, such as Radau, at
			integrating the ODE for at least one specific system--Lorenz--using only examples of
			solutions, with no explicit representation of the underlying ODE, to build up a model of
			the entire dynamics of the system. Given `),r=h(L,i),p=h(L,` points of an initial trajectory and at
			a high enough temporal resolution, the neural model demonstrated the ability to predict the
			subsequent `),A=h(L,d),D=h(L,` outputs of the Radau solver with, in most cases, high accuracy, and in
			the worst case, marginal accuracy, for all trajectories in a test set that uniformly sampled
			the phase space of the system. When used autoregressively, the model demonstrated the potential
			to generate arbitrarily long trajectories that are visually indistinguishable from typical
			trajectories of the system and that match the output of the Radau solver at least as well
			as other state-of-the-art IVP solvers such as RK45.`)},m(L,S){m(L,e,S),I(t,L,S),m(L,s,S),I(a,L,S),m(L,n,S),m(L,r,S),m(L,p,S),m(L,A,S),m(L,D,S),u=!0},p:U,i(L){u||(y(t.$$.fragment,L),y(a.$$.fragment,L),u=!0)},o(L){_(t.$$.fragment,L),_(a.$$.fragment,L),u=!1},d(L){L&&(o(e),o(s),o(n),o(r),o(p),o(A),o(D)),M(t,L),M(a,L)}}}function Xr(l){let e;return{c(){e=c(`It must be noted, however, that the amount of data and model capacity used to achieve
			these results was substantial. Roughly 100 million data points from the Lorenz Attractor
			were used to train a model with over half a billion parameters for 40 hours using two
			GPUs. Although these numbers are modest compared to many of the most successful deep
			learning applications today, they are likely still far from trivial, in my opinion. For
			how many real-world chaotic systems with no known ODE representation is it feasible to
			gather 100 million data points? And could such a large model be optimized to run
			predictions in real-time for systems that require it to? I certainly do not know, but it
			seems plausible that such requirements could pose a significant barrier in many
			real-world cases. Having said all of that, it must also be noted that maximizing data
			and model efficiency was not a focus of this project, and so the potential for
			optimization is an open question.`)},l(t){e=h(t,`It must be noted, however, that the amount of data and model capacity used to achieve
			these results was substantial. Roughly 100 million data points from the Lorenz Attractor
			were used to train a model with over half a billion parameters for 40 hours using two
			GPUs. Although these numbers are modest compared to many of the most successful deep
			learning applications today, they are likely still far from trivial, in my opinion. For
			how many real-world chaotic systems with no known ODE representation is it feasible to
			gather 100 million data points? And could such a large model be optimized to run
			predictions in real-time for systems that require it to? I certainly do not know, but it
			seems plausible that such requirements could pose a significant barrier in many
			real-world cases. Having said all of that, it must also be noted that maximizing data
			and model efficiency was not a focus of this project, and so the potential for
			optimization is an open question.`)},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Zr(l){let e;return{c(){e=c("shadowing lemma")},l(t){e=h(t,"shadowing lemma")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function Qr(l){let e,t,s,a,n,i,r,p;return t=new B({props:{href:"https://en.wikipedia.org/wiki/Shadowing_lemma",$$slots:{default:[Zr]},$$scope:{ctx:l}}}),a=new K({props:{id:"seo"}}),i=new K({props:{id:"degrave"}}),{c(){e=c(`Another, possibly more critical, open question I have is given that this model (and all
			IVP solvers) cannot actually predict the true solutions but instead can only predict
			'shadows' of true solutions (see `),b(t.$$.fragment),s=c(`), how useful can these predictions actually be in real-world applications? Is there
			any practical use for such a system, or are projects like this merely academic
			exercises? Is the true potential of deep neural networks as applied to chaotic systems
			more in their ability to prevent systems from entering chaotic regimes, as is explored
			in `),b(a.$$.fragment),n=c(`
			and `),b(i.$$.fragment),r=c(`, rather than to actually predict how chaotic dynamics will
			unfold? I suspect the answer is 'yes', although I am again far from certain. In either
			case, these results show a definite ability of generic deep neural networks to mimic the
			dynamics of a chaotic system, which may not amount to predicting future states but may
			still be enough to enable control systems to effectively manage those future states.`)},l(d){e=h(d,`Another, possibly more critical, open question I have is given that this model (and all
			IVP solvers) cannot actually predict the true solutions but instead can only predict
			'shadows' of true solutions (see `),k(t.$$.fragment,d),s=h(d,`), how useful can these predictions actually be in real-world applications? Is there
			any practical use for such a system, or are projects like this merely academic
			exercises? Is the true potential of deep neural networks as applied to chaotic systems
			more in their ability to prevent systems from entering chaotic regimes, as is explored
			in `),k(a.$$.fragment,d),n=h(d,`
			and `),k(i.$$.fragment,d),r=h(d,`, rather than to actually predict how chaotic dynamics will
			unfold? I suspect the answer is 'yes', although I am again far from certain. In either
			case, these results show a definite ability of generic deep neural networks to mimic the
			dynamics of a chaotic system, which may not amount to predicting future states but may
			still be enough to enable control systems to effectively manage those future states.`)},m(d,A){m(d,e,A),I(t,d,A),m(d,s,A),I(a,d,A),m(d,n,A),I(i,d,A),m(d,r,A),p=!0},p(d,A){const D={};A&256&&(D.$$scope={dirty:A,ctx:d}),t.$set(D)},i(d){p||(y(t.$$.fragment,d),y(a.$$.fragment,d),y(i.$$.fragment,d),p=!0)},o(d){_(t.$$.fragment,d),_(a.$$.fragment,d),_(i.$$.fragment,d),p=!1},d(d){d&&(o(e),o(s),o(n),o(r)),M(t,d),M(a,d),M(i,d)}}}function tl(l){let e;return{c(){e=c("References")},l(t){e=h(t,"References")},m(t,s){m(t,e,s)},d(t){t&&o(e)}}}function el(l){let e,t,s,a,n,i,r,p,d,A='<nav class="border-r-2 sticky top-12"><div><section><ul class="menu"><li><a href="#intro">Intro</a></li> <li><a href="#lorenz">Lorenz Attractor</a></li> <li><a href="#nhits">Neural Architecture</a></li> <li><a href="#experiments">Experiments</a></li> <ul class="text-sm submenu"><li><a href="#datagen">Data Generation</a></li> <li><a href="#model-1">Model 1</a></li> <li><a href="#model-2">Model 2</a></li> <li><a href="#model-3">Model 3</a></li> <li><a href="#arpred">Autoregressive Prediction</a></li></ul> <li><a href="#discussion">Discussion</a></li> <li><a href="#references">References</a></li></ul></section></div></nav>',D,u,L,S="Modeling Chaotic Dynamics with Deep Learning: A Case Study on the Lorenz Attractor",E,q,z="Michael Horgan",G,Z,J,F,st,Y,O,V,W,N,C,X,et,it,Qn,kt,ts,dn,Da=`<sup id="paperspace">2. All of my experiments were run on a Paperspace VM using two RTX 5000s, each
					with 16 GB of RAM.</sup>`,es,En,It,ns,Mt,ss,as,At,is,Et,os,$n,Fe,Be,Tt,Na,rs,xt,ls,zt,fs,gn,Tn,Ra=go+"",cs,hs,jt,us,wn,xn,qa=wo+"",ms,ps,Pt,ds,Lt,$s,St,gs,Dt,ws,Nt,vs,Rt,ys,qt,Gt,Ht,Ct,_s,vn,zn,Ga=vo+"",bs,ks,Vt,Ft,Is,Bt,Ms,Ut,As,Ot,Es,Wt,Ts,Ue,xs,Kt,zs,jn,Ha=yo+"",js,Ps,Jt,Ls,Yt,rt,Ca,Ss,Xt,Ds,Zt,Ns,Qt,Oe,Va=`<img class="" src="${`${Q}/Model1SmallErr.png`}" alt="" width="300" height="300"/> <img class="" src="${`${Q}/Model1MediumErr.png`}" alt="" width="300" height="300"/> <img class="" src="${`${Q}/Model1LargeErr.png`}" alt="" width="300" height="300"/>`,Rs,te,qs,ee,Gs,ne,lt,Fa,Hs,se,Cs,ae,ie,Vs,oe,ft,Ba,Fs,re,Bs,le,Us,fe,Os,ce,Ws,We,Ks,Ke,Ua=`Note that Model 2 has roughly 32x the number of trainable parameters as Model 1. I've
			increased the depth (number of stacks, blocks per stack) and width (mlp layer size) of
			the network, and I've also significantly increased the amount of compression in the
			initial stacks. Because the network is much deeper, I also added layer normalization
			after each block to try to help reduce convergence time. Lastly, I increased the number
			of training steps and reduced the initial learning rate by an order of magnitude, and I
			modified the learning rate schedule to reduce by half whenever the validation loss does
			not decrease from the previous validation step.`,Js,Je,ct,Oa,he,Ys,ue,me,Xs,Ye,ht,Wa,pe,Zs,de,Qs,Xe,ut,Ka,ta,$e,ea,ge,na,Ze,mt,Ja,we,sa,ve,aa,ye,ia,_e,oa,be,ra,Qe,la,ke,fa,ot,ca,Ya="$dt \\approx 0.003$",ha,ua,Xa="$\\lt80$",ma,pa,da,tn,pt,Za,Ie,$a,yn,Qa=`The most challenging trajectories from the test set are significantly improved, although
			still far from perfect:`,ga,Me,dt,ti,wa,Ae,va,Ee,ya,Te,_a,xe,ze,ba,en,$t,ei,je,ka,Pe,Le,Ia,Se,gt,ni,Ma,De,Aa,Ne,Ea,Re,Ta,qe,xa,Ge,He,za,Ce,ja,nn,Yn,Pa,si;return Y=new B({props:{href:"https://github.com/nrxszvo/mochaNN",$$slots:{default:[Mo]},$$scope:{ctx:l}}}),W=new H({props:{$$slots:{default:[Ao]},$$scope:{ctx:l}}}),N=new H({props:{$$slots:{default:[Eo]},$$scope:{ctx:l}}}),kt=new B({props:{href:"https://www.youtube.com/@SabineHossenfelder",$$slots:{default:[To]},$$scope:{ctx:l}}}),Mt=new B({props:{href:"https://www.youtube.com/playlist?list=PLMrJAkhIeNNTYaOnVI3QpH7jgULnAmvPA",$$slots:{default:[xo]},$$scope:{ctx:l}}}),At=new Fn({props:{id:"lorenz",$$slots:{default:[zo]},$$scope:{ctx:l}}}),Et=new H({props:{$$slots:{default:[Po]},$$scope:{ctx:l}}}),xt=new nt({props:{$$slots:{default:[Lo]},$$scope:{ctx:l}}}),zt=new H({props:{$$slots:{default:[So]},$$scope:{ctx:l}}}),jt=new H({props:{$$slots:{default:[Do]},$$scope:{ctx:l}}}),Pt=new H({props:{$$slots:{default:[Ro]},$$scope:{ctx:l}}}),Lt=new Fn({props:{id:"nhits",$$slots:{default:[qo]},$$scope:{ctx:l}}}),St=new H({props:{$$slots:{default:[Go]},$$scope:{ctx:l}}}),Dt=new H({props:{$$slots:{default:[Ho]},$$scope:{ctx:l}}}),Nt=new H({props:{$$slots:{default:[Co]},$$scope:{ctx:l}}}),Rt=new Fn({props:{id:"experiments",$$slots:{default:[Vo]},$$scope:{ctx:l}}}),qt=new H({props:{$$slots:{default:[Fo]},$$scope:{ctx:l}}}),Gt=new Bn({props:{id:"datagen",$$slots:{default:[Bo]},$$scope:{ctx:l}}}),Ht=new H({props:{$$slots:{default:[Ko]},$$scope:{ctx:l}}}),Ct=new H({props:{$$slots:{default:[Zo]},$$scope:{ctx:l}}}),Vt=new H({props:{indent:"indent-0",$$slots:{default:[Qo]},$$scope:{ctx:l}}}),Ft=new H({props:{$$slots:{default:[tr]},$$scope:{ctx:l}}}),Bt=new H({props:{indent:"indent-0",$$slots:{default:[er]},$$scope:{ctx:l}}}),Ut=new H({props:{$$slots:{default:[nr]},$$scope:{ctx:l}}}),Ot=new Bn({props:{id:"model-1",$$slots:{default:[sr]},$$scope:{ctx:l}}}),Wt=new H({props:{$$slots:{default:[ar]},$$scope:{ctx:l}}}),Ue=new La({props:{hps:_o}}),Kt=new H({props:{indent:"indent-0",$$slots:{default:[ir]},$$scope:{ctx:l}}}),Jt=new H({props:{$$slots:{default:[or]},$$scope:{ctx:l}}}),Xt=new nt({props:{$$slots:{default:[rr]},$$scope:{ctx:l}}}),Zt=new H({props:{$$slots:{default:[lr]},$$scope:{ctx:l}}}),te=new nt({props:{$$slots:{default:[fr]},$$scope:{ctx:l}}}),ee=new H({props:{$$slots:{default:[cr]},$$scope:{ctx:l}}}),se=new nt({props:{$$slots:{default:[hr]},$$scope:{ctx:l}}}),ae=new H({props:{$$slots:{default:[mr]},$$scope:{ctx:l}}}),ie=new H({props:{$$slots:{default:[pr]},$$scope:{ctx:l}}}),re=new nt({props:{$$slots:{default:[dr]},$$scope:{ctx:l}}}),le=new H({props:{$$slots:{default:[$r]},$$scope:{ctx:l}}}),fe=new Bn({props:{id:"model-2",$$slots:{default:[gr]},$$scope:{ctx:l}}}),ce=new H({props:{$$slots:{default:[wr]},$$scope:{ctx:l}}}),We=new La({props:{hps:bo}}),he=new nt({props:{$$slots:{default:[vr]},$$scope:{ctx:l}}}),ue=new H({props:{$$slots:{default:[yr]},$$scope:{ctx:l}}}),me=new H({props:{$$slots:{default:[_r]},$$scope:{ctx:l}}}),pe=new nt({props:{$$slots:{default:[br]},$$scope:{ctx:l}}}),de=new H({props:{$$slots:{default:[kr]},$$scope:{ctx:l}}}),$e=new nt({props:{$$slots:{default:[Ir]},$$scope:{ctx:l}}}),ge=new H({props:{$$slots:{default:[Mr]},$$scope:{ctx:l}}}),we=new nt({props:{$$slots:{default:[Ar]},$$scope:{ctx:l}}}),ve=new H({props:{$$slots:{default:[Er]},$$scope:{ctx:l}}}),ye=new H({props:{$$slots:{default:[Tr]},$$scope:{ctx:l}}}),_e=new Bn({props:{id:"model-3",$$slots:{default:[xr]},$$scope:{ctx:l}}}),be=new H({props:{$$slots:{default:[zr]},$$scope:{ctx:l}}}),Qe=new La({props:{hps:ko}}),ke=new H({props:{style:"my-4 text-xs font-serif",$$slots:{default:[Pr]},$$scope:{ctx:l}}}),Ie=new nt({props:{$$slots:{default:[Lr]},$$scope:{ctx:l}}}),Ae=new nt({props:{$$slots:{default:[Sr]},$$scope:{ctx:l}}}),Ee=new H({props:{$$slots:{default:[Dr]},$$scope:{ctx:l}}}),Te=new Bn({props:{id:"arpred",$$slots:{default:[Nr]},$$scope:{ctx:l}}}),xe=new H({props:{$$slots:{default:[Rr]},$$scope:{ctx:l}}}),ze=new H({props:{$$slots:{default:[qr]},$$scope:{ctx:l}}}),je=new nt({props:{$$slots:{default:[Gr]},$$scope:{ctx:l}}}),Pe=new H({props:{$$slots:{default:[Cr]},$$scope:{ctx:l}}}),Le=new H({props:{$$slots:{default:[Ur]},$$scope:{ctx:l}}}),De=new nt({props:{$$slots:{default:[Wr]},$$scope:{ctx:l}}}),Ne=new H({props:{$$slots:{default:[Kr]},$$scope:{ctx:l}}}),Re=new Fn({props:{id:"discussion",$$slots:{default:[Jr]},$$scope:{ctx:l}}}),qe=new H({props:{$$slots:{default:[Yr]},$$scope:{ctx:l}}}),Ge=new H({props:{$$slots:{default:[Xr]},$$scope:{ctx:l}}}),He=new H({props:{$$slots:{default:[Qr]},$$scope:{ctx:l}}}),Ce=new Fn({props:{id:"references",$$slots:{default:[tl]},$$scope:{ctx:l}}}),nn=new no({}),{c(){e=j("meta"),t=j("meta"),s=j("meta"),a=j("meta"),n=j("meta"),i=j("meta"),r=T(),p=j("div"),d=j("aside"),d.innerHTML=A,D=T(),u=j("div"),L=j("div"),L.textContent=S,E=T(),q=j("div"),q.textContent=z,G=T(),Z=j("br"),J=T(),F=j("div"),st=c("(All code used in this project is available in the github repo: "),b(Y.$$.fragment),O=c(")"),V=T(),b(W.$$.fragment),b(N.$$.fragment),C=T(),X=j("div"),et=j("p"),it=j("sup"),Qn=c(`1. For a quick and entertaining way to stay informed of new developments in the
					world of DL for dynamical systems modeling, I highly recommend Sabine
					Hossenfelder's `),b(kt.$$.fragment),ts=T(),dn=j("p"),dn.innerHTML=Da,es=T(),En=j("p"),It=j("sup"),ns=c(`3. If you would like to refresh your background on dynamical systems theory, I
					highly recommend Steve Brunton's free `),b(Mt.$$.fragment),ss=c(" on the subject"),as=T(),b(At.$$.fragment),is=T(),b(Et.$$.fragment),os=T(),$n=j("div"),Fe=j("a"),Be=j("figure"),Tt=j("img"),rs=T(),b(xt.$$.fragment),ls=T(),b(zt.$$.fragment),fs=T(),gn=j("div"),Tn=j("p"),cs=c(Ra),hs=T(),b(jt.$$.fragment),us=T(),wn=j("div"),xn=j("p"),ms=c(qa),ps=T(),b(Pt.$$.fragment),ds=T(),b(Lt.$$.fragment),$s=T(),b(St.$$.fragment),gs=T(),b(Dt.$$.fragment),ws=T(),b(Nt.$$.fragment),vs=T(),b(Rt.$$.fragment),ys=T(),b(qt.$$.fragment),b(Gt.$$.fragment),b(Ht.$$.fragment),b(Ct.$$.fragment),_s=T(),vn=j("div"),zn=j("p"),bs=c(Ga),ks=T(),b(Vt.$$.fragment),b(Ft.$$.fragment),Is=T(),b(Bt.$$.fragment),Ms=T(),b(Ut.$$.fragment),As=T(),b(Ot.$$.fragment),Es=T(),b(Wt.$$.fragment),Ts=T(),b(Ue.$$.fragment),xs=T(),b(Kt.$$.fragment),zs=T(),jn=j("div"),js=c(Ha),Ps=T(),b(Jt.$$.fragment),Ls=T(),Yt=j("figure"),rt=j("img"),Ss=T(),b(Xt.$$.fragment),Ds=T(),b(Zt.$$.fragment),Ns=T(),Qt=j("figure"),Oe=j("div"),Oe.innerHTML=Va,Rs=T(),b(te.$$.fragment),qs=T(),b(ee.$$.fragment),Gs=T(),ne=j("figure"),lt=j("img"),Hs=T(),b(se.$$.fragment),Cs=T(),b(ae.$$.fragment),b(ie.$$.fragment),Vs=T(),oe=j("figure"),ft=j("img"),Fs=T(),b(re.$$.fragment),Bs=T(),b(le.$$.fragment),Us=T(),b(fe.$$.fragment),Os=T(),b(ce.$$.fragment),Ws=T(),b(We.$$.fragment),Ks=T(),Ke=j("p"),Ke.textContent=Ua,Js=T(),Je=j("figure"),ct=j("img"),b(he.$$.fragment),Ys=T(),b(ue.$$.fragment),b(me.$$.fragment),Xs=T(),Ye=j("figure"),ht=j("img"),b(pe.$$.fragment),Zs=T(),b(de.$$.fragment),Qs=T(),Xe=j("figure"),ut=j("img"),ta=T(),b($e.$$.fragment),ea=T(),b(ge.$$.fragment),na=T(),Ze=j("figure"),mt=j("img"),b(we.$$.fragment),sa=T(),b(ve.$$.fragment),aa=T(),b(ye.$$.fragment),ia=T(),b(_e.$$.fragment),oa=T(),b(be.$$.fragment),ra=T(),b(Qe.$$.fragment),la=T(),b(ke.$$.fragment),fa=T(),ot=j("p"),ca=c(`After retraining Model 2 with a new dataset that samples the Lorenz Attractor
			trajectories with `),ha=c(Ya),ua=c(`, we see that we are now able to predict all
			regions of the test set with sMAPE error `),ma=c(Xa),pa=c(":"),da=T(),tn=j("figure"),pt=j("img"),b(Ie.$$.fragment),$a=T(),yn=j("p"),yn.textContent=Qa,ga=T(),Me=j("figure"),dt=j("img"),wa=T(),b(Ae.$$.fragment),va=T(),b(Ee.$$.fragment),ya=T(),b(Te.$$.fragment),_a=T(),b(xe.$$.fragment),b(ze.$$.fragment),ba=T(),en=j("figure"),$t=j("img"),b(je.$$.fragment),ka=T(),b(Pe.$$.fragment),b(Le.$$.fragment),Ia=T(),Se=j("figure"),gt=j("img"),Ma=T(),b(De.$$.fragment),Aa=T(),b(Ne.$$.fragment),Ea=T(),b(Re.$$.fragment),Ta=T(),b(qe.$$.fragment),xa=T(),b(Ge.$$.fragment),b(He.$$.fragment),za=T(),b(Ce.$$.fragment),ja=T(),b(nn.$$.fragment),this.h()},l(f){const w=Ji("svelte-1w17oz4",Ve.head);e=P(w,"META",{name:!0,content:!0}),t=P(w,"META",{property:!0,content:!0}),s=P(w,"META",{property:!0,content:!0}),a=P(w,"META",{property:!0,content:!0}),n=P(w,"META",{property:!0,content:!0}),i=P(w,"META",{property:!0,content:!0}),w.forEach(o),r=x(f),p=P(f,"DIV",{class:!0});var sn=R(p);d=P(sn,"ASIDE",{"data-svelte-h":!0}),tt(d)!=="svelte-1jc65ah"&&(d.innerHTML=A),D=x(sn),u=P(sn,"DIV",{class:!0});var g=R(u);L=P(g,"DIV",{id:!0,class:!0,"data-svelte-h":!0}),tt(L)!=="svelte-g7eo4d"&&(L.textContent=S),E=x(g),q=P(g,"DIV",{class:!0,"data-svelte-h":!0}),tt(q)!=="svelte-hve5fy"&&(q.textContent=z),G=x(g),Z=P(g,"BR",{}),J=x(g),F=P(g,"DIV",{class:!0});var an=R(F);st=h(an,"(All code used in this project is available in the github repo: "),k(Y.$$.fragment,an),O=h(an,")"),an.forEach(o),V=x(g),k(W.$$.fragment,g),k(N.$$.fragment,g),C=x(g),X=P(g,"DIV",{class:!0});var wt=R(X);et=P(wt,"P",{});var Pn=R(et);it=P(Pn,"SUP",{id:!0});var _n=R(it);Qn=h(_n,`1. For a quick and entertaining way to stay informed of new developments in the
					world of DL for dynamical systems modeling, I highly recommend Sabine
					Hossenfelder's `),k(kt.$$.fragment,_n),_n.forEach(o),Pn.forEach(o),ts=x(wt),dn=P(wt,"P",{"data-svelte-h":!0}),tt(dn)!=="svelte-7qdhvn"&&(dn.innerHTML=Da),es=x(wt),En=P(wt,"P",{});var Ln=R(En);It=P(Ln,"SUP",{id:!0});var on=R(It);ns=h(on,`3. If you would like to refresh your background on dynamical systems theory, I
					highly recommend Steve Brunton's free `),k(Mt.$$.fragment,on),ss=h(on," on the subject"),on.forEach(o),Ln.forEach(o),wt.forEach(o),as=x(g),k(At.$$.fragment,g),is=x(g),k(Et.$$.fragment,g),os=x(g),$n=P(g,"DIV",{class:!0});var Sn=R($n);Fe=P(Sn,"A",{title:!0,href:!0});var Dn=R(Fe);Be=P(Dn,"FIGURE",{});var rn=R(Be);Tt=P(rn,"IMG",{class:!0,width:!0,alt:!0,src:!0}),rs=x(rn),k(xt.$$.fragment,rn),rn.forEach(o),Dn.forEach(o),Sn.forEach(o),ls=x(g),k(zt.$$.fragment,g),fs=x(g),gn=P(g,"DIV",{class:!0});var Nn=R(gn);Tn=P(Nn,"P",{});var Rn=R(Tn);cs=h(Rn,Ra),Rn.forEach(o),Nn.forEach(o),hs=x(g),k(jt.$$.fragment,g),us=x(g),wn=P(g,"DIV",{class:!0});var qn=R(wn);xn=P(qn,"P",{});var Gn=R(xn);ms=h(Gn,qa),Gn.forEach(o),qn.forEach(o),ps=x(g),k(Pt.$$.fragment,g),ds=x(g),k(Lt.$$.fragment,g),$s=x(g),k(St.$$.fragment,g),gs=x(g),k(Dt.$$.fragment,g),ws=x(g),k(Nt.$$.fragment,g),vs=x(g),k(Rt.$$.fragment,g),ys=x(g),k(qt.$$.fragment,g),k(Gt.$$.fragment,g),k(Ht.$$.fragment,g),k(Ct.$$.fragment,g),_s=x(g),vn=P(g,"DIV",{class:!0});var Hn=R(vn);zn=P(Hn,"P",{});var Cn=R(zn);bs=h(Cn,Ga),Cn.forEach(o),Hn.forEach(o),ks=x(g),k(Vt.$$.fragment,g),k(Ft.$$.fragment,g),Is=x(g),k(Bt.$$.fragment,g),Ms=x(g),k(Ut.$$.fragment,g),As=x(g),k(Ot.$$.fragment,g),Es=x(g),k(Wt.$$.fragment,g),Ts=x(g),k(Ue.$$.fragment,g),xs=x(g),k(Kt.$$.fragment,g),zs=x(g),jn=P(g,"DIV",{});var Vn=R(jn);js=h(Vn,Ha),Vn.forEach(o),Ps=x(g),k(Jt.$$.fragment,g),Ls=x(g),Yt=P(g,"FIGURE",{class:!0});var ln=R(Yt);rt=P(ln,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),Ss=x(ln),k(Xt.$$.fragment,ln),ln.forEach(o),Ds=x(g),k(Zt.$$.fragment,g),Ns=x(g),Qt=P(g,"FIGURE",{class:!0});var fn=R(Qt);Oe=P(fn,"DIV",{class:!0,"data-svelte-h":!0}),tt(Oe)!=="svelte-1hknb0z"&&(Oe.innerHTML=Va),Rs=x(fn),k(te.$$.fragment,fn),fn.forEach(o),qs=x(g),k(ee.$$.fragment,g),Gs=x(g),ne=P(g,"FIGURE",{class:!0});var cn=R(ne);lt=P(cn,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),Hs=x(cn),k(se.$$.fragment,cn),cn.forEach(o),Cs=x(g),k(ae.$$.fragment,g),k(ie.$$.fragment,g),Vs=x(g),oe=P(g,"FIGURE",{class:!0});var hn=R(oe);ft=P(hn,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),Fs=x(hn),k(re.$$.fragment,hn),hn.forEach(o),Bs=x(g),k(le.$$.fragment,g),Us=x(g),k(fe.$$.fragment,g),Os=x(g),k(ce.$$.fragment,g),Ws=x(g),k(We.$$.fragment,g),Ks=x(g),Ke=P(g,"P",{class:!0,"data-svelte-h":!0}),tt(Ke)!=="svelte-8lzr6y"&&(Ke.textContent=Ua),Js=x(g),Je=P(g,"FIGURE",{class:!0});var bn=R(Je);ct=P(bn,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),k(he.$$.fragment,bn),bn.forEach(o),Ys=x(g),k(ue.$$.fragment,g),k(me.$$.fragment,g),Xs=x(g),Ye=P(g,"FIGURE",{class:!0});var kn=R(Ye);ht=P(kn,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),k(pe.$$.fragment,kn),kn.forEach(o),Zs=x(g),k(de.$$.fragment,g),Qs=x(g),Xe=P(g,"FIGURE",{});var un=R(Xe);ut=P(un,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),ta=x(un),k($e.$$.fragment,un),un.forEach(o),ea=x(g),k(ge.$$.fragment,g),na=x(g),Ze=P(g,"FIGURE",{class:!0});var In=R(Ze);mt=P(In,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),k(we.$$.fragment,In),In.forEach(o),sa=x(g),k(ve.$$.fragment,g),aa=x(g),k(ye.$$.fragment,g),ia=x(g),k(_e.$$.fragment,g),oa=x(g),k(be.$$.fragment,g),ra=x(g),k(Qe.$$.fragment,g),la=x(g),k(ke.$$.fragment,g),fa=x(g),ot=P(g,"P",{class:!0});var vt=R(ot);ca=h(vt,`After retraining Model 2 with a new dataset that samples the Lorenz Attractor
			trajectories with `),ha=h(vt,Ya),ua=h(vt,`, we see that we are now able to predict all
			regions of the test set with sMAPE error `),ma=h(vt,Xa),pa=h(vt,":"),vt.forEach(o),da=x(g),tn=P(g,"FIGURE",{class:!0});var Mn=R(tn);pt=P(Mn,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),k(Ie.$$.fragment,Mn),Mn.forEach(o),$a=x(g),yn=P(g,"P",{"data-svelte-h":!0}),tt(yn)!=="svelte-8g9ay2"&&(yn.textContent=Qa),ga=x(g),Me=P(g,"FIGURE",{class:!0});var mn=R(Me);dt=P(mn,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),wa=x(mn),k(Ae.$$.fragment,mn),mn.forEach(o),va=x(g),k(Ee.$$.fragment,g),ya=x(g),k(Te.$$.fragment,g),_a=x(g),k(xe.$$.fragment,g),k(ze.$$.fragment,g),ba=x(g),en=P(g,"FIGURE",{class:!0});var An=R(en);$t=P(An,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),k(je.$$.fragment,An),An.forEach(o),ka=x(g),k(Pe.$$.fragment,g),k(Le.$$.fragment,g),Ia=x(g),Se=P(g,"FIGURE",{class:!0});var pn=R(Se);gt=P(pn,"IMG",{class:!0,src:!0,alt:!0,width:!0,height:!0}),Ma=x(pn),k(De.$$.fragment,pn),pn.forEach(o),Aa=x(g),k(Ne.$$.fragment,g),Ea=x(g),k(Re.$$.fragment,g),Ta=x(g),k(qe.$$.fragment,g),xa=x(g),k(Ge.$$.fragment,g),k(He.$$.fragment,g),za=x(g),k(Ce.$$.fragment,g),ja=x(g),k(nn.$$.fragment,g),g.forEach(o),sn.forEach(o),this.h()},h(){Ve.title="Modeling Chaotic Dynamics with Deep Learning: A Case Study on the Lorenz Attractor",v(e,"name","description"),v(e,"content","Experiments using the NHiTS neural forecasting architecture to model the Lorenz Attractor"),v(t,"property","og:type"),v(t,"content","article"),v(s,"property","og:url"),v(s,"content","https://nrxszvo.github.io/nhits-lorenz"),v(a,"property","og:description"),v(a,"content","Experiments using the NHiTS neural forecasting architecture to model the Lorenz Attractor"),v(n,"property","og:image"),v(n,"content","https://nrxszvo.github.io/thumbnail.png"),v(i,"property","og:title"),v(i,"content","Modeling Chaotic Dynamics with Deep Learning: A Case Study on the Lorenz Attractor"),v(L,"id","intro"),v(L,"class","mt-8 text-2xl text-center"),v(q,"class","mt-2 text-sm text-center"),v(F,"class","text-sm text-center font-serif mb-4"),v(it,"id","sabine"),v(It,"id","brunton"),v(X,"class","my-4 ms-4 -indent-4 font-serif leading-4"),v(Tt,"class","m-auto"),v(Tt,"width","128"),v(Tt,"alt","A Trajectory Through Phase Space in a Lorenz Attractor"),at(Tt.src,Na="https://upload.wikimedia.org/wikipedia/commons/1/13/A_Trajectory_Through_Phase_Space_in_a_Lorenz_Attractor.gif")||v(Tt,"src",Na),v(Fe,"title","Dan Quinn, CC BY-SA 3.0 <https://creativecommons.org/licenses/by-sa/3.0>, via Wikimedia Commons"),v(Fe,"href","https://commons.wikimedia.org/wiki/File:A_Trajectory_Through_Phase_Space_in_a_Lorenz_Attractor.gif"),v($n,"class","my-2 self-center"),v(gn,"class","self-center"),v(wn,"class","self-center"),v(vn,"class","self-center"),v(rt,"class","m-auto"),at(rt.src,Ca=`${Q}/Model1ErrDist.png`)||v(rt,"src",Ca),v(rt,"alt",""),v(rt,"width","600"),v(rt,"height","600"),v(Yt,"class","mb-6 self-center"),v(Oe,"class","flex flex-wrap justify-center"),v(Qt,"class","mt-6 mb-6 self-center"),v(lt,"class","m-auto"),at(lt.src,Fa=`${Q}/model-1-pod.gif`)||v(lt,"src",Fa),v(lt,"alt","prediction point of divergence"),v(lt,"width","450"),v(lt,"height","350"),v(ne,"class","mt-6 mb-6 self-center"),v(ft,"class","m-auto"),at(ft.src,Ba=`${Q}/trajectories.gif`)||v(ft,"src",Ba),v(ft,"alt","trajectories approaching origin"),v(ft,"width","350"),v(ft,"height","300"),v(oe,"class","mt-6 mb-6 self-center"),v(Ke,"class","mt-2"),v(ct,"class","m-auto"),at(ct.src,Oa=`${Q}/Model2ErrDist.png`)||v(ct,"src",Oa),v(ct,"alt",""),v(ct,"width","600"),v(ct,"height","600"),v(Je,"class","mb-2 self-center"),v(ht,"class","m-auto"),at(ht.src,Wa=`${Q}/Model2Err3d.png`)||v(ht,"src",Wa),v(ht,"alt",""),v(ht,"width","600"),v(ht,"height","600"),v(Ye,"class","-mt-2 mb-2 self-center"),v(ut,"class","m-auto"),at(ut.src,Ka=`${Q}/model-2-pod.gif`)||v(ut,"src",Ka),v(ut,"alt","model 2 point of divergence"),v(ut,"width","400"),v(ut,"height","340"),v(mt,"class","m-auto"),at(mt.src,Ja=`${Q}/Model2DFO.png`)||v(mt,"src",Ja),v(mt,"alt","distance from origin vs. sMAPE"),v(mt,"width","800"),v(mt,"height","600"),v(Ze,"class","-mt-2 mb-2 self-center"),v(ot,"class","mt-4"),v(pt,"class","m-auto"),at(pt.src,Za=`${Q}/Model2vModel3.png`)||v(pt,"src",Za),v(pt,"alt",""),v(pt,"width","600"),v(pt,"height","600"),v(tn,"class","mb-8 self-center"),v(dt,"class","m-auto"),at(dt.src,ti=`${Q}/model-3-low-dfo.gif`)||v(dt,"src",ti),v(dt,"alt","Model 3 trajectory example"),v(dt,"width","800"),v(dt,"height","800"),v(Me,"class","my-8 self-center"),v($t,"class","m-auto"),at($t.src,ei=`${Q}/ref_v_ar.png`)||v($t,"src",ei),v($t,"alt","Reference vs. Autoregressive Trajectories"),v($t,"width","450"),v($t,"height","500"),v(en,"class","mb-2 self-center"),v(gt,"class","m-auto"),at(gt.src,ni=`${Q}/rk45_vs_nhits.png`)||v(gt,"src",ni),v(gt,"alt","Comparison of RK45 and predictions to Radua's solutions"),v(gt,"width","600"),v(gt,"height","600"),v(Se,"class","mb-2 self-center"),v(u,"class","flex flex-col mx-4 sm:mx-16"),v(p,"class","grid grid-flow-col auto-cols-auto")},m(f,w){$(Ve.head,e),$(Ve.head,t),$(Ve.head,s),$(Ve.head,a),$(Ve.head,n),$(Ve.head,i),m(f,r,w),m(f,p,w),$(p,d),$(p,D),$(p,u),$(u,L),$(u,E),$(u,q),$(u,G),$(u,Z),$(u,J),$(u,F),$(F,st),I(Y,F,null),$(F,O),$(u,V),I(W,u,null),I(N,u,null),$(u,C),$(u,X),$(X,et),$(et,it),$(it,Qn),I(kt,it,null),$(X,ts),$(X,dn),$(X,es),$(X,En),$(En,It),$(It,ns),I(Mt,It,null),$(It,ss),$(u,as),I(At,u,null),$(u,is),I(Et,u,null),$(u,os),$(u,$n),$($n,Fe),$(Fe,Be),$(Be,Tt),$(Be,rs),I(xt,Be,null),$(u,ls),I(zt,u,null),$(u,fs),$(u,gn),$(gn,Tn),$(Tn,cs),$(u,hs),I(jt,u,null),$(u,us),$(u,wn),$(wn,xn),$(xn,ms),$(u,ps),I(Pt,u,null),$(u,ds),I(Lt,u,null),$(u,$s),I(St,u,null),$(u,gs),I(Dt,u,null),$(u,ws),I(Nt,u,null),$(u,vs),I(Rt,u,null),$(u,ys),I(qt,u,null),I(Gt,u,null),I(Ht,u,null),I(Ct,u,null),$(u,_s),$(u,vn),$(vn,zn),$(zn,bs),$(u,ks),I(Vt,u,null),I(Ft,u,null),$(u,Is),I(Bt,u,null),$(u,Ms),I(Ut,u,null),$(u,As),I(Ot,u,null),$(u,Es),I(Wt,u,null),$(u,Ts),I(Ue,u,null),$(u,xs),I(Kt,u,null),$(u,zs),$(u,jn),$(jn,js),$(u,Ps),I(Jt,u,null),$(u,Ls),$(u,Yt),$(Yt,rt),$(Yt,Ss),I(Xt,Yt,null),$(u,Ds),I(Zt,u,null),$(u,Ns),$(u,Qt),$(Qt,Oe),$(Qt,Rs),I(te,Qt,null),$(u,qs),I(ee,u,null),$(u,Gs),$(u,ne),$(ne,lt),$(ne,Hs),I(se,ne,null),$(u,Cs),I(ae,u,null),I(ie,u,null),$(u,Vs),$(u,oe),$(oe,ft),$(oe,Fs),I(re,oe,null),$(u,Bs),I(le,u,null),$(u,Us),I(fe,u,null),$(u,Os),I(ce,u,null),$(u,Ws),I(We,u,null),$(u,Ks),$(u,Ke),$(u,Js),$(u,Je),$(Je,ct),I(he,Je,null),$(u,Ys),I(ue,u,null),I(me,u,null),$(u,Xs),$(u,Ye),$(Ye,ht),I(pe,Ye,null),$(u,Zs),I(de,u,null),$(u,Qs),$(u,Xe),$(Xe,ut),$(Xe,ta),I($e,Xe,null),$(u,ea),I(ge,u,null),$(u,na),$(u,Ze),$(Ze,mt),I(we,Ze,null),$(u,sa),I(ve,u,null),$(u,aa),I(ye,u,null),$(u,ia),I(_e,u,null),$(u,oa),I(be,u,null),$(u,ra),I(Qe,u,null),$(u,la),I(ke,u,null),$(u,fa),$(u,ot),$(ot,ca),$(ot,ha),$(ot,ua),$(ot,ma),$(ot,pa),$(u,da),$(u,tn),$(tn,pt),I(Ie,tn,null),$(u,$a),$(u,yn),$(u,ga),$(u,Me),$(Me,dt),$(Me,wa),I(Ae,Me,null),$(u,va),I(Ee,u,null),$(u,ya),I(Te,u,null),$(u,_a),I(xe,u,null),I(ze,u,null),$(u,ba),$(u,en),$(en,$t),I(je,en,null),$(u,ka),I(Pe,u,null),I(Le,u,null),$(u,Ia),$(u,Se),$(Se,gt),$(Se,Ma),I(De,Se,null),$(u,Aa),I(Ne,u,null),$(u,Ea),I(Re,u,null),$(u,Ta),I(qe,u,null),$(u,xa),I(Ge,u,null),I(He,u,null),$(u,za),I(Ce,u,null),$(u,ja),I(nn,u,null),Yn=!0,Pa||(si=Yi(Io,"scroll",l[0]),Pa=!0)},p(f,[w]){const sn={};w&256&&(sn.$$scope={dirty:w,ctx:f}),Y.$set(sn);const g={};w&256&&(g.$$scope={dirty:w,ctx:f}),W.$set(g);const an={};w&256&&(an.$$scope={dirty:w,ctx:f}),N.$set(an);const wt={};w&256&&(wt.$$scope={dirty:w,ctx:f}),kt.$set(wt);const Pn={};w&256&&(Pn.$$scope={dirty:w,ctx:f}),Mt.$set(Pn);const _n={};w&256&&(_n.$$scope={dirty:w,ctx:f}),At.$set(_n);const Ln={};w&256&&(Ln.$$scope={dirty:w,ctx:f}),Et.$set(Ln);const on={};w&256&&(on.$$scope={dirty:w,ctx:f}),xt.$set(on);const Sn={};w&256&&(Sn.$$scope={dirty:w,ctx:f}),zt.$set(Sn);const Dn={};w&256&&(Dn.$$scope={dirty:w,ctx:f}),jt.$set(Dn);const rn={};w&256&&(rn.$$scope={dirty:w,ctx:f}),Pt.$set(rn);const Nn={};w&256&&(Nn.$$scope={dirty:w,ctx:f}),Lt.$set(Nn);const Rn={};w&256&&(Rn.$$scope={dirty:w,ctx:f}),St.$set(Rn);const qn={};w&256&&(qn.$$scope={dirty:w,ctx:f}),Dt.$set(qn);const Gn={};w&256&&(Gn.$$scope={dirty:w,ctx:f}),Nt.$set(Gn);const Hn={};w&256&&(Hn.$$scope={dirty:w,ctx:f}),Rt.$set(Hn);const Cn={};w&256&&(Cn.$$scope={dirty:w,ctx:f}),qt.$set(Cn);const Vn={};w&256&&(Vn.$$scope={dirty:w,ctx:f}),Gt.$set(Vn);const ln={};w&256&&(ln.$$scope={dirty:w,ctx:f}),Ht.$set(ln);const fn={};w&256&&(fn.$$scope={dirty:w,ctx:f}),Ct.$set(fn);const cn={};w&256&&(cn.$$scope={dirty:w,ctx:f}),Vt.$set(cn);const hn={};w&256&&(hn.$$scope={dirty:w,ctx:f}),Ft.$set(hn);const bn={};w&256&&(bn.$$scope={dirty:w,ctx:f}),Bt.$set(bn);const kn={};w&256&&(kn.$$scope={dirty:w,ctx:f}),Ut.$set(kn);const un={};w&256&&(un.$$scope={dirty:w,ctx:f}),Ot.$set(un);const In={};w&256&&(In.$$scope={dirty:w,ctx:f}),Wt.$set(In);const vt={};w&256&&(vt.$$scope={dirty:w,ctx:f}),Kt.$set(vt);const Mn={};w&256&&(Mn.$$scope={dirty:w,ctx:f}),Jt.$set(Mn);const mn={};w&256&&(mn.$$scope={dirty:w,ctx:f}),Xt.$set(mn);const An={};w&256&&(An.$$scope={dirty:w,ctx:f}),Zt.$set(An);const pn={};w&256&&(pn.$$scope={dirty:w,ctx:f}),te.$set(pn);const ai={};w&256&&(ai.$$scope={dirty:w,ctx:f}),ee.$set(ai);const ii={};w&256&&(ii.$$scope={dirty:w,ctx:f}),se.$set(ii);const oi={};w&256&&(oi.$$scope={dirty:w,ctx:f}),ae.$set(oi);const ri={};w&256&&(ri.$$scope={dirty:w,ctx:f}),ie.$set(ri);const li={};w&256&&(li.$$scope={dirty:w,ctx:f}),re.$set(li);const fi={};w&256&&(fi.$$scope={dirty:w,ctx:f}),le.$set(fi);const ci={};w&256&&(ci.$$scope={dirty:w,ctx:f}),fe.$set(ci);const hi={};w&256&&(hi.$$scope={dirty:w,ctx:f}),ce.$set(hi);const ui={};w&256&&(ui.$$scope={dirty:w,ctx:f}),he.$set(ui);const mi={};w&256&&(mi.$$scope={dirty:w,ctx:f}),ue.$set(mi);const pi={};w&256&&(pi.$$scope={dirty:w,ctx:f}),me.$set(pi);const di={};w&256&&(di.$$scope={dirty:w,ctx:f}),pe.$set(di);const $i={};w&256&&($i.$$scope={dirty:w,ctx:f}),de.$set($i);const gi={};w&256&&(gi.$$scope={dirty:w,ctx:f}),$e.$set(gi);const wi={};w&256&&(wi.$$scope={dirty:w,ctx:f}),ge.$set(wi);const vi={};w&256&&(vi.$$scope={dirty:w,ctx:f}),we.$set(vi);const yi={};w&256&&(yi.$$scope={dirty:w,ctx:f}),ve.$set(yi);const _i={};w&256&&(_i.$$scope={dirty:w,ctx:f}),ye.$set(_i);const bi={};w&256&&(bi.$$scope={dirty:w,ctx:f}),_e.$set(bi);const ki={};w&256&&(ki.$$scope={dirty:w,ctx:f}),be.$set(ki);const Ii={};w&256&&(Ii.$$scope={dirty:w,ctx:f}),ke.$set(Ii);const Mi={};w&256&&(Mi.$$scope={dirty:w,ctx:f}),Ie.$set(Mi);const Ai={};w&256&&(Ai.$$scope={dirty:w,ctx:f}),Ae.$set(Ai);const Ei={};w&256&&(Ei.$$scope={dirty:w,ctx:f}),Ee.$set(Ei);const Ti={};w&256&&(Ti.$$scope={dirty:w,ctx:f}),Te.$set(Ti);const xi={};w&256&&(xi.$$scope={dirty:w,ctx:f}),xe.$set(xi);const zi={};w&256&&(zi.$$scope={dirty:w,ctx:f}),ze.$set(zi);const ji={};w&256&&(ji.$$scope={dirty:w,ctx:f}),je.$set(ji);const Pi={};w&256&&(Pi.$$scope={dirty:w,ctx:f}),Pe.$set(Pi);const Li={};w&256&&(Li.$$scope={dirty:w,ctx:f}),Le.$set(Li);const Si={};w&256&&(Si.$$scope={dirty:w,ctx:f}),De.$set(Si);const Di={};w&256&&(Di.$$scope={dirty:w,ctx:f}),Ne.$set(Di);const Ni={};w&256&&(Ni.$$scope={dirty:w,ctx:f}),Re.$set(Ni);const Ri={};w&256&&(Ri.$$scope={dirty:w,ctx:f}),qe.$set(Ri);const qi={};w&256&&(qi.$$scope={dirty:w,ctx:f}),Ge.$set(qi);const Gi={};w&256&&(Gi.$$scope={dirty:w,ctx:f}),He.$set(Gi);const Hi={};w&256&&(Hi.$$scope={dirty:w,ctx:f}),Ce.$set(Hi)},i(f){Yn||(y(Y.$$.fragment,f),y(W.$$.fragment,f),y(N.$$.fragment,f),y(kt.$$.fragment,f),y(Mt.$$.fragment,f),y(At.$$.fragment,f),y(Et.$$.fragment,f),y(xt.$$.fragment,f),y(zt.$$.fragment,f),y(jt.$$.fragment,f),y(Pt.$$.fragment,f),y(Lt.$$.fragment,f),y(St.$$.fragment,f),y(Dt.$$.fragment,f),y(Nt.$$.fragment,f),y(Rt.$$.fragment,f),y(qt.$$.fragment,f),y(Gt.$$.fragment,f),y(Ht.$$.fragment,f),y(Ct.$$.fragment,f),y(Vt.$$.fragment,f),y(Ft.$$.fragment,f),y(Bt.$$.fragment,f),y(Ut.$$.fragment,f),y(Ot.$$.fragment,f),y(Wt.$$.fragment,f),y(Ue.$$.fragment,f),y(Kt.$$.fragment,f),y(Jt.$$.fragment,f),y(Xt.$$.fragment,f),y(Zt.$$.fragment,f),y(te.$$.fragment,f),y(ee.$$.fragment,f),y(se.$$.fragment,f),y(ae.$$.fragment,f),y(ie.$$.fragment,f),y(re.$$.fragment,f),y(le.$$.fragment,f),y(fe.$$.fragment,f),y(ce.$$.fragment,f),y(We.$$.fragment,f),y(he.$$.fragment,f),y(ue.$$.fragment,f),y(me.$$.fragment,f),y(pe.$$.fragment,f),y(de.$$.fragment,f),y($e.$$.fragment,f),y(ge.$$.fragment,f),y(we.$$.fragment,f),y(ve.$$.fragment,f),y(ye.$$.fragment,f),y(_e.$$.fragment,f),y(be.$$.fragment,f),y(Qe.$$.fragment,f),y(ke.$$.fragment,f),y(Ie.$$.fragment,f),y(Ae.$$.fragment,f),y(Ee.$$.fragment,f),y(Te.$$.fragment,f),y(xe.$$.fragment,f),y(ze.$$.fragment,f),y(je.$$.fragment,f),y(Pe.$$.fragment,f),y(Le.$$.fragment,f),y(De.$$.fragment,f),y(Ne.$$.fragment,f),y(Re.$$.fragment,f),y(qe.$$.fragment,f),y(Ge.$$.fragment,f),y(He.$$.fragment,f),y(Ce.$$.fragment,f),y(nn.$$.fragment,f),Yn=!0)},o(f){_(Y.$$.fragment,f),_(W.$$.fragment,f),_(N.$$.fragment,f),_(kt.$$.fragment,f),_(Mt.$$.fragment,f),_(At.$$.fragment,f),_(Et.$$.fragment,f),_(xt.$$.fragment,f),_(zt.$$.fragment,f),_(jt.$$.fragment,f),_(Pt.$$.fragment,f),_(Lt.$$.fragment,f),_(St.$$.fragment,f),_(Dt.$$.fragment,f),_(Nt.$$.fragment,f),_(Rt.$$.fragment,f),_(qt.$$.fragment,f),_(Gt.$$.fragment,f),_(Ht.$$.fragment,f),_(Ct.$$.fragment,f),_(Vt.$$.fragment,f),_(Ft.$$.fragment,f),_(Bt.$$.fragment,f),_(Ut.$$.fragment,f),_(Ot.$$.fragment,f),_(Wt.$$.fragment,f),_(Ue.$$.fragment,f),_(Kt.$$.fragment,f),_(Jt.$$.fragment,f),_(Xt.$$.fragment,f),_(Zt.$$.fragment,f),_(te.$$.fragment,f),_(ee.$$.fragment,f),_(se.$$.fragment,f),_(ae.$$.fragment,f),_(ie.$$.fragment,f),_(re.$$.fragment,f),_(le.$$.fragment,f),_(fe.$$.fragment,f),_(ce.$$.fragment,f),_(We.$$.fragment,f),_(he.$$.fragment,f),_(ue.$$.fragment,f),_(me.$$.fragment,f),_(pe.$$.fragment,f),_(de.$$.fragment,f),_($e.$$.fragment,f),_(ge.$$.fragment,f),_(we.$$.fragment,f),_(ve.$$.fragment,f),_(ye.$$.fragment,f),_(_e.$$.fragment,f),_(be.$$.fragment,f),_(Qe.$$.fragment,f),_(ke.$$.fragment,f),_(Ie.$$.fragment,f),_(Ae.$$.fragment,f),_(Ee.$$.fragment,f),_(Te.$$.fragment,f),_(xe.$$.fragment,f),_(ze.$$.fragment,f),_(je.$$.fragment,f),_(Pe.$$.fragment,f),_(Le.$$.fragment,f),_(De.$$.fragment,f),_(Ne.$$.fragment,f),_(Re.$$.fragment,f),_(qe.$$.fragment,f),_(Ge.$$.fragment,f),_(He.$$.fragment,f),_(Ce.$$.fragment,f),_(nn.$$.fragment,f),Yn=!1},d(f){f&&(o(r),o(p)),o(e),o(t),o(s),o(a),o(n),o(i),M(Y),M(W),M(N),M(kt),M(Mt),M(At),M(Et),M(xt),M(zt),M(jt),M(Pt),M(Lt),M(St),M(Dt),M(Nt),M(Rt),M(qt),M(Gt),M(Ht),M(Ct),M(Vt),M(Ft),M(Bt),M(Ut),M(Ot),M(Wt),M(Ue),M(Kt),M(Jt),M(Xt),M(Zt),M(te),M(ee),M(se),M(ae),M(ie),M(re),M(le),M(fe),M(ce),M(We),M(he),M(ue),M(me),M(pe),M(de),M($e),M(ge),M(we),M(ve),M(ye),M(_e),M(be),M(Qe),M(ke),M(Ie),M(Ae),M(Ee),M(Te),M(xe),M(ze),M(je),M(Pe),M(Le),M(De),M(Ne),M(Re),M(qe),M(Ge),M(He),M(Ce),M(nn),Pa=!1,si()}}}function nl(l){const e=["intro","lorenz","nhits","experiments","datagen","model-1","model-2","model-3","arpred","discussion","references"],t=["bg-rose-100","rounded"];let s=e[0];const a=p=>{const d="a[href='#"+p+"']";return document.querySelector(d)},n=p=>{const d=a(p).parentElement;t.forEach(A=>d.classList.add(A))},i=p=>{const d=a(p).parentElement;t.forEach(A=>d.classList.remove(A))},r=()=>{let p;const d=window.outerHeight;console.log("wHeight",d,"scrollY",window.scrollY),e.forEach(A=>{const D=document.getElementById(A);console.log(A,D.offsetTop),window.scrollY>=D.offsetTop-1&&(p=A)}),p&&p!=s&&(i(s),s=p,n(s))};return Oi(()=>{n(s),r();let p=document.createElement("script");p.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js",p.async=!0,document.head.append(p),window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},processEscapes:!0}}),[r]}class ol extends _t{constructor(e){super(),bt(this,e,nl,el,yt,{})}}export{ol as component};
